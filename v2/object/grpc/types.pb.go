// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v2/object/grpc/types.proto

package object

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "github.com/nspcc-dev/neofs-api-go/v2/refs/grpc"
	grpc1 "github.com/nspcc-dev/neofs-api-go/v2/session/grpc"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Type of the object payload content.
type ObjectType int32

const (
	// Just a normal object
	ObjectType_REGULAR ObjectType = 0
	// Used internally to identify deleted objects
	ObjectType_TOMBSTONE ObjectType = 1
	// StorageGroup information
	ObjectType_STORAGE_GROUP ObjectType = 2
)

var ObjectType_name = map[int32]string{
	0: "REGULAR",
	1: "TOMBSTONE",
	2: "STORAGE_GROUP",
}

var ObjectType_value = map[string]int32{
	"REGULAR":       0,
	"TOMBSTONE":     1,
	"STORAGE_GROUP": 2,
}

func (x ObjectType) String() string {
	return proto.EnumName(ObjectType_name, int32(x))
}

func (ObjectType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_545319325da7b9b1, []int{0}
}

// Type of match expression
type MatchType int32

const (
	// Unknown. Not used
	MatchType_MATCH_TYPE_UNSPECIFIED MatchType = 0
	// Full string match
	MatchType_STRING_EQUAL MatchType = 1
)

var MatchType_name = map[int32]string{
	0: "MATCH_TYPE_UNSPECIFIED",
	1: "STRING_EQUAL",
}

var MatchType_value = map[string]int32{
	"MATCH_TYPE_UNSPECIFIED": 0,
	"STRING_EQUAL":           1,
}

func (x MatchType) String() string {
	return proto.EnumName(MatchType_name, int32(x))
}

func (MatchType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_545319325da7b9b1, []int{1}
}

// Short header fields
type ShortHeader struct {
	// Object format version. Effectively the version of API library used to
	// create particular object
	Version *grpc.Version `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Epoch when the object was created
	CreationEpoch uint64 `protobuf:"varint,2,opt,name=creation_epoch,json=creationEpoch,proto3" json:"creation_epoch,omitempty"`
	// Object's owner
	OwnerId *grpc.OwnerID `protobuf:"bytes,3,opt,name=owner_id,json=ownerID,proto3" json:"owner_id,omitempty"`
	// Type of the object payload content
	ObjectType ObjectType `protobuf:"varint,4,opt,name=object_type,json=objectType,proto3,enum=neo.fs.v2.object.ObjectType" json:"object_type,omitempty"`
	// Size of payload in bytes.
	// `0xFFFFFFFFFFFFFFFF` means `payload_length` is unknown
	PayloadLength        uint64   `protobuf:"varint,5,opt,name=payload_length,json=payloadLength,proto3" json:"payload_length,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShortHeader) Reset()         { *m = ShortHeader{} }
func (m *ShortHeader) String() string { return proto.CompactTextString(m) }
func (*ShortHeader) ProtoMessage()    {}
func (*ShortHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_545319325da7b9b1, []int{0}
}
func (m *ShortHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShortHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShortHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShortHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShortHeader.Merge(m, src)
}
func (m *ShortHeader) XXX_Size() int {
	return m.Size()
}
func (m *ShortHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ShortHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ShortHeader proto.InternalMessageInfo

func (m *ShortHeader) GetVersion() *grpc.Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *ShortHeader) GetCreationEpoch() uint64 {
	if m != nil {
		return m.CreationEpoch
	}
	return 0
}

func (m *ShortHeader) GetOwnerId() *grpc.OwnerID {
	if m != nil {
		return m.OwnerId
	}
	return nil
}

func (m *ShortHeader) GetObjectType() ObjectType {
	if m != nil {
		return m.ObjectType
	}
	return ObjectType_REGULAR
}

func (m *ShortHeader) GetPayloadLength() uint64 {
	if m != nil {
		return m.PayloadLength
	}
	return 0
}

// Object Header
type Header struct {
	// Object format version. Effectively the version of API library used to
	// create particular object
	Version *grpc.Version `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Object's container
	ContainerId *grpc.ContainerID `protobuf:"bytes,2,opt,name=container_id,json=containerID,proto3" json:"container_id,omitempty"`
	// Object's owner
	OwnerId *grpc.OwnerID `protobuf:"bytes,3,opt,name=owner_id,json=ownerID,proto3" json:"owner_id,omitempty"`
	// Object creation Epoch
	CreationEpoch uint64 `protobuf:"varint,4,opt,name=creation_epoch,json=creationEpoch,proto3" json:"creation_epoch,omitempty"`
	// Size of payload in bytes.
	// `0xFFFFFFFFFFFFFFFF` means `payload_length` is unknown
	PayloadLength uint64 `protobuf:"varint,5,opt,name=payload_length,json=payloadLength,proto3" json:"payload_length,omitempty"`
	// Hash of payload bytes
	PayloadHash *grpc.Checksum `protobuf:"bytes,6,opt,name=payload_hash,json=payloadHash,proto3" json:"payload_hash,omitempty"`
	// Type of the object payload content
	ObjectType ObjectType `protobuf:"varint,7,opt,name=object_type,json=objectType,proto3,enum=neo.fs.v2.object.ObjectType" json:"object_type,omitempty"`
	// Homomorphic hash of the object payload.
	HomomorphicHash *grpc.Checksum `protobuf:"bytes,8,opt,name=homomorphic_hash,json=homomorphicHash,proto3" json:"homomorphic_hash,omitempty"`
	// Session token, if it was used during Object creation. Need it to verify
	// integrity and authenticity out of Request scope.
	SessionToken *grpc1.SessionToken `protobuf:"bytes,9,opt,name=session_token,json=sessionToken,proto3" json:"session_token,omitempty"`
	// User-defined object attributes
	Attributes []*Header_Attribute `protobuf:"bytes,10,rep,name=attributes,proto3" json:"attributes,omitempty"`
	// Position of the object in the split hierarchy
	Split                *Header_Split `protobuf:"bytes,11,opt,name=split,proto3" json:"split,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_545319325da7b9b1, []int{1}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

func (m *Header) GetVersion() *grpc.Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *Header) GetContainerId() *grpc.ContainerID {
	if m != nil {
		return m.ContainerId
	}
	return nil
}

func (m *Header) GetOwnerId() *grpc.OwnerID {
	if m != nil {
		return m.OwnerId
	}
	return nil
}

func (m *Header) GetCreationEpoch() uint64 {
	if m != nil {
		return m.CreationEpoch
	}
	return 0
}

func (m *Header) GetPayloadLength() uint64 {
	if m != nil {
		return m.PayloadLength
	}
	return 0
}

func (m *Header) GetPayloadHash() *grpc.Checksum {
	if m != nil {
		return m.PayloadHash
	}
	return nil
}

func (m *Header) GetObjectType() ObjectType {
	if m != nil {
		return m.ObjectType
	}
	return ObjectType_REGULAR
}

func (m *Header) GetHomomorphicHash() *grpc.Checksum {
	if m != nil {
		return m.HomomorphicHash
	}
	return nil
}

func (m *Header) GetSessionToken() *grpc1.SessionToken {
	if m != nil {
		return m.SessionToken
	}
	return nil
}

func (m *Header) GetAttributes() []*Header_Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Header) GetSplit() *Header_Split {
	if m != nil {
		return m.Split
	}
	return nil
}

// `Attribute` is a user-defined Key-Value metadata pair attached to the
// object.
//
// There are some "well-known" attributes starting with `__NEOFS__` prefix
// that affect system behaviour:
//
// * __NEOFS__UPLOAD_ID
// * __NEOFS__EXPIRATION_EPOCH
//
// For detailed description of each well-known attribute please see the
// corresponding section in NeoFS Technical specification.
type Header_Attribute struct {
	// string key to the object attribute
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// string value of the object attribute
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Header_Attribute) Reset()         { *m = Header_Attribute{} }
func (m *Header_Attribute) String() string { return proto.CompactTextString(m) }
func (*Header_Attribute) ProtoMessage()    {}
func (*Header_Attribute) Descriptor() ([]byte, []int) {
	return fileDescriptor_545319325da7b9b1, []int{1, 0}
}
func (m *Header_Attribute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header_Attribute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header_Attribute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header_Attribute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header_Attribute.Merge(m, src)
}
func (m *Header_Attribute) XXX_Size() int {
	return m.Size()
}
func (m *Header_Attribute) XXX_DiscardUnknown() {
	xxx_messageInfo_Header_Attribute.DiscardUnknown(m)
}

var xxx_messageInfo_Header_Attribute proto.InternalMessageInfo

func (m *Header_Attribute) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Header_Attribute) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Bigger objects can be split into a chain of smaller objects. Information
// about inter-dependencies between spawned objects and how to re-construct
// the original one is in the `Split` headers. Parent and children objects
// must be within the same container.
type Header_Split struct {
	// Identifier of the origin object. Known only to the minor child.
	Parent *grpc.ObjectID `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// Identifier of the left split neighbor
	Previous *grpc.ObjectID `protobuf:"bytes,2,opt,name=previous,proto3" json:"previous,omitempty"`
	// `signature` field of the parent object. Used to reconstruct parent.
	ParentSignature *grpc.Signature `protobuf:"bytes,3,opt,name=parent_signature,json=parentSignature,proto3" json:"parent_signature,omitempty"`
	// `header` field of the parent object. Used to reconstruct parent.
	ParentHeader *Header `protobuf:"bytes,4,opt,name=parent_header,json=parentHeader,proto3" json:"parent_header,omitempty"`
	// List of identifiers of the objects generated by splitting current one.
	Children             []*grpc.ObjectID `protobuf:"bytes,5,rep,name=children,proto3" json:"children,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Header_Split) Reset()         { *m = Header_Split{} }
func (m *Header_Split) String() string { return proto.CompactTextString(m) }
func (*Header_Split) ProtoMessage()    {}
func (*Header_Split) Descriptor() ([]byte, []int) {
	return fileDescriptor_545319325da7b9b1, []int{1, 1}
}
func (m *Header_Split) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header_Split) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header_Split.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header_Split) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header_Split.Merge(m, src)
}
func (m *Header_Split) XXX_Size() int {
	return m.Size()
}
func (m *Header_Split) XXX_DiscardUnknown() {
	xxx_messageInfo_Header_Split.DiscardUnknown(m)
}

var xxx_messageInfo_Header_Split proto.InternalMessageInfo

func (m *Header_Split) GetParent() *grpc.ObjectID {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *Header_Split) GetPrevious() *grpc.ObjectID {
	if m != nil {
		return m.Previous
	}
	return nil
}

func (m *Header_Split) GetParentSignature() *grpc.Signature {
	if m != nil {
		return m.ParentSignature
	}
	return nil
}

func (m *Header_Split) GetParentHeader() *Header {
	if m != nil {
		return m.ParentHeader
	}
	return nil
}

func (m *Header_Split) GetChildren() []*grpc.ObjectID {
	if m != nil {
		return m.Children
	}
	return nil
}

// Object structure. Object is immutable and content-addressed. It means
// `ObjectID` will change if header or payload changes. It's calculated as a
// hash of header field, which contains hash of object's payload.
type Object struct {
	// Object's unique identifier.
	ObjectId *grpc.ObjectID `protobuf:"bytes,1,opt,name=object_id,json=objectID,proto3" json:"object_id,omitempty"`
	// Signed object_id
	Signature *grpc.Signature `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	// Object metadata headers
	Header *Header `protobuf:"bytes,3,opt,name=header,proto3" json:"header,omitempty"`
	// Payload bytes.
	Payload              []byte   `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Object) Reset()         { *m = Object{} }
func (m *Object) String() string { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()    {}
func (*Object) Descriptor() ([]byte, []int) {
	return fileDescriptor_545319325da7b9b1, []int{2}
}
func (m *Object) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Object) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Object.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Object) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Object.Merge(m, src)
}
func (m *Object) XXX_Size() int {
	return m.Size()
}
func (m *Object) XXX_DiscardUnknown() {
	xxx_messageInfo_Object.DiscardUnknown(m)
}

var xxx_messageInfo_Object proto.InternalMessageInfo

func (m *Object) GetObjectId() *grpc.ObjectID {
	if m != nil {
		return m.ObjectId
	}
	return nil
}

func (m *Object) GetSignature() *grpc.Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Object) GetHeader() *Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Object) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func init() {
	proto.RegisterEnum("neo.fs.v2.object.ObjectType", ObjectType_name, ObjectType_value)
	proto.RegisterEnum("neo.fs.v2.object.MatchType", MatchType_name, MatchType_value)
	proto.RegisterType((*ShortHeader)(nil), "neo.fs.v2.object.ShortHeader")
	proto.RegisterType((*Header)(nil), "neo.fs.v2.object.Header")
	proto.RegisterType((*Header_Attribute)(nil), "neo.fs.v2.object.Header.Attribute")
	proto.RegisterType((*Header_Split)(nil), "neo.fs.v2.object.Header.Split")
	proto.RegisterType((*Object)(nil), "neo.fs.v2.object.Object")
}

func init() { proto.RegisterFile("v2/object/grpc/types.proto", fileDescriptor_545319325da7b9b1) }

var fileDescriptor_545319325da7b9b1 = []byte{
	// 793 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xae, 0xd3, 0xe6, 0xef, 0x38, 0xd9, 0x35, 0x03, 0x02, 0x93, 0x45, 0xa1, 0xaa, 0x84, 0x54,
	0xad, 0x54, 0x1b, 0xbc, 0x45, 0x2b, 0x54, 0x2d, 0x52, 0xda, 0x78, 0xdb, 0x48, 0x6d, 0x53, 0xc6,
	0x2e, 0x12, 0xdc, 0x58, 0xae, 0x33, 0x8d, 0x4d, 0x53, 0x8f, 0xe5, 0x99, 0x18, 0xf5, 0x92, 0xb7,
	0xe0, 0x19, 0xf6, 0x39, 0xb8, 0xe0, 0x92, 0x47, 0x58, 0x95, 0x17, 0x41, 0x9e, 0x19, 0x37, 0x6d,
	0xb3, 0x4b, 0x60, 0xaf, 0x7c, 0xe6, 0xcc, 0xf7, 0x9d, 0x39, 0xdf, 0x37, 0x67, 0x64, 0xe8, 0x15,
	0x8e, 0x4d, 0x2f, 0x7e, 0x21, 0x11, 0xb7, 0xa7, 0x79, 0x16, 0xd9, 0xfc, 0x26, 0x23, 0xcc, 0xca,
	0x72, 0xca, 0x29, 0x32, 0x52, 0x42, 0xad, 0x4b, 0x66, 0x15, 0x8e, 0x25, 0x21, 0x3d, 0xb3, 0x70,
	0xec, 0x9c, 0x5c, 0xb2, 0x25, 0x6c, 0xef, 0x59, 0xe1, 0xd8, 0x8c, 0x30, 0x96, 0xd0, 0x74, 0x69,
	0x73, 0xeb, 0xb7, 0x1a, 0xe8, 0x5e, 0x4c, 0x73, 0x7e, 0x44, 0xc2, 0x09, 0xc9, 0xd1, 0x37, 0xd0,
	0x2c, 0x48, 0x5e, 0x62, 0x4d, 0x6d, 0x53, 0xdb, 0xd6, 0x9d, 0xcf, 0xac, 0xc5, 0x51, 0x65, 0x7d,
	0xeb, 0x47, 0xb9, 0x8d, 0x2b, 0x1c, 0xfa, 0x0a, 0x9e, 0x44, 0x39, 0x09, 0x79, 0x42, 0xd3, 0x80,
	0x64, 0x34, 0x8a, 0xcd, 0xda, 0xa6, 0xb6, 0xbd, 0x81, 0xbb, 0x55, 0xd6, 0x2d, 0x93, 0xc8, 0x81,
	0x16, 0xfd, 0x35, 0x25, 0x79, 0x90, 0x4c, 0xcc, 0xf5, 0x77, 0x97, 0x1e, 0x97, 0xfb, 0xa3, 0x21,
	0x6e, 0x52, 0x19, 0xa0, 0x57, 0xa0, 0x4b, 0x79, 0x41, 0xd9, 0xb3, 0xb9, 0xb1, 0xa9, 0x6d, 0x3f,
	0x71, 0xbe, 0xb0, 0x1e, 0x8b, 0xb7, 0xc6, 0xe2, 0xe3, 0xdf, 0x64, 0x04, 0x03, 0xbd, 0x8b, 0xcb,
	0xce, 0xb2, 0xf0, 0x66, 0x46, 0xc3, 0x49, 0x30, 0x23, 0xe9, 0x94, 0xc7, 0x66, 0x5d, 0x76, 0xa6,
	0xb2, 0xc7, 0x22, 0xb9, 0xf5, 0xb6, 0x09, 0x8d, 0x0f, 0x97, 0xff, 0x3d, 0x74, 0x22, 0x9a, 0xf2,
	0x30, 0x51, 0xda, 0x6a, 0x82, 0xf7, 0xec, 0x31, 0xef, 0xa0, 0xc2, 0x8c, 0x86, 0x58, 0x8f, 0x16,
	0x8b, 0x0f, 0xf2, 0x65, 0xd9, 0xf2, 0x8d, 0x77, 0x59, 0xfe, 0xdf, 0xf4, 0xa3, 0x3d, 0xe8, 0x54,
	0xb0, 0x38, 0x64, 0xb1, 0xd9, 0x10, 0x5d, 0x98, 0x4b, 0x0a, 0x62, 0x12, 0x5d, 0xb1, 0xf9, 0x35,
	0xd6, 0x15, 0xfa, 0x28, 0x64, 0xf1, 0xe3, 0x2b, 0x6a, 0xfe, 0xcf, 0x2b, 0x3a, 0x00, 0x23, 0xa6,
	0xd7, 0xf4, 0x9a, 0xe6, 0x59, 0x9c, 0x44, 0xf2, 0xfc, 0xd6, 0x8a, 0xf3, 0x9f, 0xde, 0x63, 0x88,
	0x1e, 0x86, 0xd0, 0x55, 0x03, 0x1e, 0x70, 0x7a, 0x45, 0x52, 0xb3, 0x2d, 0x2a, 0x7c, 0x79, 0xaf,
	0x82, 0xda, 0xb7, 0x3c, 0xf9, 0xf5, 0x4b, 0x18, 0xee, 0xb0, 0x7b, 0x2b, 0xb4, 0x0f, 0x10, 0x72,
	0x9e, 0x27, 0x17, 0x73, 0x4e, 0x98, 0x09, 0x9b, 0xeb, 0xdb, 0xba, 0xb3, 0xb5, 0x2c, 0x44, 0x4e,
	0x8a, 0x35, 0xa8, 0xa0, 0xf8, 0x1e, 0x0b, 0xed, 0x42, 0x9d, 0x65, 0xb3, 0x84, 0x9b, 0xba, 0xe8,
	0xa0, 0xff, 0x5e, 0xba, 0x57, 0xa2, 0xb0, 0x04, 0xf7, 0x5e, 0x40, 0xfb, 0xae, 0x1c, 0x32, 0x60,
	0xfd, 0x8a, 0xdc, 0x88, 0xf1, 0x6b, 0xe3, 0x32, 0x44, 0x9f, 0x40, 0xbd, 0x08, 0x67, 0x73, 0x22,
	0x46, 0xab, 0x8d, 0xe5, 0xa2, 0xf7, 0xa6, 0x06, 0x75, 0x51, 0x05, 0x7d, 0x0d, 0x8d, 0x2c, 0xcc,
	0x49, 0xca, 0xd5, 0xcc, 0x2e, 0x39, 0x27, 0xbd, 0x1f, 0x0d, 0xb1, 0xc2, 0xa1, 0x5d, 0x68, 0x65,
	0x39, 0x29, 0x12, 0x3a, 0x67, 0x6a, 0x5e, 0xdf, 0xcf, 0xb9, 0x43, 0xa2, 0x21, 0x18, 0x92, 0x1f,
	0xb0, 0x64, 0x9a, 0x86, 0x7c, 0x9e, 0x13, 0x35, 0xb1, 0x9f, 0x3f, 0x66, 0x7b, 0x15, 0x00, 0x3f,
	0x95, 0x94, 0xbb, 0x04, 0x7a, 0x05, 0x5d, 0x55, 0x25, 0x16, 0x56, 0x88, 0xd1, 0x7d, 0xd8, 0xc0,
	0x03, 0xab, 0x70, 0x47, 0xc2, 0xd5, 0x0b, 0xdd, 0x85, 0x56, 0x14, 0x27, 0xb3, 0x49, 0x4e, 0x52,
	0xb3, 0x2e, 0xee, 0xe8, 0x5f, 0x5a, 0xaf, 0x90, 0x5b, 0x7f, 0x68, 0xd0, 0x90, 0x69, 0xf4, 0x2d,
	0xb4, 0xd5, 0xc0, 0x26, 0x93, 0x95, 0x86, 0xb5, 0xa8, 0x8a, 0xd0, 0x4b, 0x68, 0x2f, 0x54, 0xd7,
	0x56, 0xa9, 0x5e, 0x60, 0xcb, 0xdb, 0x51, 0x42, 0xd7, 0x57, 0x08, 0x55, 0x38, 0x64, 0x42, 0x53,
	0xbd, 0x30, 0xe1, 0x4d, 0x07, 0x57, 0xcb, 0xe7, 0x7b, 0x00, 0x8b, 0x77, 0x84, 0x74, 0x68, 0x62,
	0xf7, 0xf0, 0xfc, 0x78, 0x80, 0x8d, 0x35, 0xd4, 0x85, 0xb6, 0x3f, 0x3e, 0xd9, 0xf7, 0xfc, 0xf1,
	0xa9, 0x6b, 0x68, 0xe8, 0x23, 0xe8, 0x7a, 0xfe, 0x18, 0x0f, 0x0e, 0xdd, 0xe0, 0x10, 0x8f, 0xcf,
	0xcf, 0x8c, 0xda, 0xf3, 0xef, 0xa0, 0x7d, 0x12, 0xf2, 0x28, 0x16, 0xdc, 0x1e, 0x7c, 0x7a, 0x32,
	0xf0, 0x0f, 0x8e, 0x02, 0xff, 0xa7, 0x33, 0x37, 0x38, 0x3f, 0xf5, 0xce, 0xdc, 0x83, 0xd1, 0xeb,
	0x91, 0x3b, 0x34, 0xd6, 0x90, 0x01, 0x1d, 0xcf, 0xc7, 0xa3, 0xd3, 0xc3, 0xc0, 0xfd, 0xe1, 0x7c,
	0x70, 0x6c, 0x68, 0xfb, 0xc1, 0x9f, 0xb7, 0x7d, 0xed, 0xaf, 0xdb, 0xbe, 0xf6, 0xf6, 0xb6, 0xaf,
	0xfd, 0xfe, 0x77, 0x7f, 0xed, 0xe7, 0x97, 0xd3, 0x84, 0xc7, 0xf3, 0x0b, 0x2b, 0xa2, 0xd7, 0x76,
	0xca, 0xb2, 0x28, 0xda, 0x99, 0x90, 0xc2, 0x4e, 0x09, 0xbd, 0x64, 0x3b, 0x61, 0x96, 0xec, 0x4c,
	0xa9, 0xfd, 0xf0, 0xf7, 0xb5, 0x27, 0xe3, 0x37, 0xb5, 0x8f, 0x4f, 0x09, 0x7d, 0xed, 0x59, 0x83,
	0xb3, 0x51, 0xe9, 0x80, 0x94, 0x73, 0xd1, 0x10, 0x7f, 0xa3, 0x17, 0xff, 0x04, 0x00, 0x00, 0xff,
	0xff, 0x21, 0xf4, 0xc9, 0x66, 0xf4, 0x06, 0x00, 0x00,
}

func (m *ShortHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShortHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShortHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PayloadLength != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PayloadLength))
		i--
		dAtA[i] = 0x28
	}
	if m.ObjectType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ObjectType))
		i--
		dAtA[i] = 0x20
	}
	if m.OwnerId != nil {
		{
			size, err := m.OwnerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CreationEpoch != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreationEpoch))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Split != nil {
		{
			size, err := m.Split.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.SessionToken != nil {
		{
			size, err := m.SessionToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.HomomorphicHash != nil {
		{
			size, err := m.HomomorphicHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ObjectType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ObjectType))
		i--
		dAtA[i] = 0x38
	}
	if m.PayloadHash != nil {
		{
			size, err := m.PayloadHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.PayloadLength != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PayloadLength))
		i--
		dAtA[i] = 0x28
	}
	if m.CreationEpoch != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreationEpoch))
		i--
		dAtA[i] = 0x20
	}
	if m.OwnerId != nil {
		{
			size, err := m.OwnerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ContainerId != nil {
		{
			size, err := m.ContainerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Header_Attribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header_Attribute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Attribute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Header_Split) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header_Split) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Split) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ParentHeader != nil {
		{
			size, err := m.ParentHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ParentSignature != nil {
		{
			size, err := m.ParentSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Previous != nil {
		{
			size, err := m.Previous.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Parent != nil {
		{
			size, err := m.Parent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Object) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Object) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x22
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ObjectId != nil {
		{
			size, err := m.ObjectId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ShortHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreationEpoch != 0 {
		n += 1 + sovTypes(uint64(m.CreationEpoch))
	}
	if m.OwnerId != nil {
		l = m.OwnerId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ObjectType != 0 {
		n += 1 + sovTypes(uint64(m.ObjectType))
	}
	if m.PayloadLength != 0 {
		n += 1 + sovTypes(uint64(m.PayloadLength))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ContainerId != nil {
		l = m.ContainerId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OwnerId != nil {
		l = m.OwnerId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreationEpoch != 0 {
		n += 1 + sovTypes(uint64(m.CreationEpoch))
	}
	if m.PayloadLength != 0 {
		n += 1 + sovTypes(uint64(m.PayloadLength))
	}
	if m.PayloadHash != nil {
		l = m.PayloadHash.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ObjectType != 0 {
		n += 1 + sovTypes(uint64(m.ObjectType))
	}
	if m.HomomorphicHash != nil {
		l = m.HomomorphicHash.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SessionToken != nil {
		l = m.SessionToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Split != nil {
		l = m.Split.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Header_Attribute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Header_Split) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Parent != nil {
		l = m.Parent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Previous != nil {
		l = m.Previous.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ParentSignature != nil {
		l = m.ParentSignature.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ParentHeader != nil {
		l = m.ParentHeader.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Object) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectId != nil {
		l = m.ObjectId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ShortHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShortHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShortHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &grpc.Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationEpoch", wireType)
			}
			m.CreationEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerId == nil {
				m.OwnerId = &grpc.OwnerID{}
			}
			if err := m.OwnerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectType", wireType)
			}
			m.ObjectType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectType |= ObjectType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadLength", wireType)
			}
			m.PayloadLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &grpc.Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerId == nil {
				m.ContainerId = &grpc.ContainerID{}
			}
			if err := m.ContainerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerId == nil {
				m.OwnerId = &grpc.OwnerID{}
			}
			if err := m.OwnerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationEpoch", wireType)
			}
			m.CreationEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadLength", wireType)
			}
			m.PayloadLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PayloadHash == nil {
				m.PayloadHash = &grpc.Checksum{}
			}
			if err := m.PayloadHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectType", wireType)
			}
			m.ObjectType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectType |= ObjectType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomomorphicHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HomomorphicHash == nil {
				m.HomomorphicHash = &grpc.Checksum{}
			}
			if err := m.HomomorphicHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SessionToken == nil {
				m.SessionToken = &grpc1.SessionToken{}
			}
			if err := m.SessionToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &Header_Attribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Split", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Split == nil {
				m.Split = &Header_Split{}
			}
			if err := m.Split.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header_Attribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header_Split) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Split: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Split: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parent == nil {
				m.Parent = &grpc.ObjectID{}
			}
			if err := m.Parent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Previous", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Previous == nil {
				m.Previous = &grpc.ObjectID{}
			}
			if err := m.Previous.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParentSignature == nil {
				m.ParentSignature = &grpc.Signature{}
			}
			if err := m.ParentSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParentHeader == nil {
				m.ParentHeader = &Header{}
			}
			if err := m.ParentHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &grpc.ObjectID{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectId == nil {
				m.ObjectId = &grpc.ObjectID{}
			}
			if err := m.ObjectId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &grpc.Signature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
