// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v2/acl/grpc/types.proto

package acl

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "github.com/nspcc-dev/neofs-api-go/v2/refs/grpc"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Target role of the access control rule in access control list.
type Role int32

const (
	// Unspecified  role, default value
	Role_ROLE_UNSPECIFIED Role = 0
	// User target rule is applied if sender is the owner of the container
	Role_USER Role = 1
	// System target rule is applied if sender is the storage node within the
	// container or inner ring node
	Role_SYSTEM Role = 2
	// Others target rule is applied if sender is not user nor system target
	Role_OTHERS Role = 3
)

var Role_name = map[int32]string{
	0: "ROLE_UNSPECIFIED",
	1: "USER",
	2: "SYSTEM",
	3: "OTHERS",
}

var Role_value = map[string]int32{
	"ROLE_UNSPECIFIED": 0,
	"USER":             1,
	"SYSTEM":           2,
	"OTHERS":           3,
}

func (x Role) String() string {
	return proto.EnumName(Role_name, int32(x))
}

func (Role) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{0}
}

// MatchType is an enumeration of match types.
type MatchType int32

const (
	// Unspecified match type, default value.
	MatchType_MATCH_TYPE_UNSPECIFIED MatchType = 0
	// Return true if strings are equal
	MatchType_STRING_EQUAL MatchType = 1
	// Return true if strings are different
	MatchType_STRING_NOT_EQUAL MatchType = 2
)

var MatchType_name = map[int32]string{
	0: "MATCH_TYPE_UNSPECIFIED",
	1: "STRING_EQUAL",
	2: "STRING_NOT_EQUAL",
}

var MatchType_value = map[string]int32{
	"MATCH_TYPE_UNSPECIFIED": 0,
	"STRING_EQUAL":           1,
	"STRING_NOT_EQUAL":       2,
}

func (x MatchType) String() string {
	return proto.EnumName(MatchType_name, int32(x))
}

func (MatchType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{1}
}

// Request's operation type to match if the rule is applicable to a particular
// request.
type Operation int32

const (
	// Unspecified operation, default value
	Operation_OPERATION_UNSPECIFIED Operation = 0
	// Get
	Operation_GET Operation = 1
	// Head
	Operation_HEAD Operation = 2
	// Put
	Operation_PUT Operation = 3
	// Delete
	Operation_DELETE Operation = 4
	// Search
	Operation_SEARCH Operation = 5
	// GetRange
	Operation_GETRANGE Operation = 6
	// GetRangeHash
	Operation_GETRANGEHASH Operation = 7
)

var Operation_name = map[int32]string{
	0: "OPERATION_UNSPECIFIED",
	1: "GET",
	2: "HEAD",
	3: "PUT",
	4: "DELETE",
	5: "SEARCH",
	6: "GETRANGE",
	7: "GETRANGEHASH",
}

var Operation_value = map[string]int32{
	"OPERATION_UNSPECIFIED": 0,
	"GET":                   1,
	"HEAD":                  2,
	"PUT":                   3,
	"DELETE":                4,
	"SEARCH":                5,
	"GETRANGE":              6,
	"GETRANGEHASH":          7,
}

func (x Operation) String() string {
	return proto.EnumName(Operation_name, int32(x))
}

func (Operation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{2}
}

// Rule execution result action. Either allows or denies access if the rule's
// filters match.
type Action int32

const (
	// Unspecified action, default value
	Action_ACTION_UNSPECIFIED Action = 0
	// Allow action
	Action_ALLOW Action = 1
	// Deny action
	Action_DENY Action = 2
)

var Action_name = map[int32]string{
	0: "ACTION_UNSPECIFIED",
	1: "ALLOW",
	2: "DENY",
}

var Action_value = map[string]int32{
	"ACTION_UNSPECIFIED": 0,
	"ALLOW":              1,
	"DENY":               2,
}

func (x Action) String() string {
	return proto.EnumName(Action_name, int32(x))
}

func (Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{3}
}

// Enumeration of possible sources of Headers to apply filters.
type HeaderType int32

const (
	// Unspecified header, default value.
	HeaderType_HEADER_UNSPECIFIED HeaderType = 0
	// Filter request headers
	HeaderType_REQUEST HeaderType = 1
	// Filter object headers
	HeaderType_OBJECT HeaderType = 2
)

var HeaderType_name = map[int32]string{
	0: "HEADER_UNSPECIFIED",
	1: "REQUEST",
	2: "OBJECT",
}

var HeaderType_value = map[string]int32{
	"HEADER_UNSPECIFIED": 0,
	"REQUEST":            1,
	"OBJECT":             2,
}

func (x HeaderType) String() string {
	return proto.EnumName(HeaderType_name, int32(x))
}

func (HeaderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{4}
}

// Describes a single eACL rule.
type EACLRecord struct {
	// NeoFS request Verb to match
	Operation Operation `protobuf:"varint,1,opt,name=operation,proto3,enum=neo.fs.v2.acl.Operation" json:"operation,omitempty"`
	// Rule execution result. Either allows or denies access if filters match.
	Action Action `protobuf:"varint,2,opt,name=action,proto3,enum=neo.fs.v2.acl.Action" json:"action,omitempty"`
	// List of filters to match and see if rule is applicable
	Filters []*EACLRecord_Filter `protobuf:"bytes,3,rep,name=filters,proto3" json:"filters,omitempty"`
	// List of target subjects to apply ACL rule to
	Targets              []*EACLRecord_Target `protobuf:"bytes,4,rep,name=targets,proto3" json:"targets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *EACLRecord) Reset()         { *m = EACLRecord{} }
func (m *EACLRecord) String() string { return proto.CompactTextString(m) }
func (*EACLRecord) ProtoMessage()    {}
func (*EACLRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{0}
}
func (m *EACLRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EACLRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EACLRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EACLRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EACLRecord.Merge(m, src)
}
func (m *EACLRecord) XXX_Size() int {
	return m.Size()
}
func (m *EACLRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_EACLRecord.DiscardUnknown(m)
}

var xxx_messageInfo_EACLRecord proto.InternalMessageInfo

func (m *EACLRecord) GetOperation() Operation {
	if m != nil {
		return m.Operation
	}
	return Operation_OPERATION_UNSPECIFIED
}

func (m *EACLRecord) GetAction() Action {
	if m != nil {
		return m.Action
	}
	return Action_ACTION_UNSPECIFIED
}

func (m *EACLRecord) GetFilters() []*EACLRecord_Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *EACLRecord) GetTargets() []*EACLRecord_Target {
	if m != nil {
		return m.Targets
	}
	return nil
}

// Filter to check particular properties of the request or object.
type EACLRecord_Filter struct {
	// Define if Object or Request header will be used
	HeaderType HeaderType `protobuf:"varint,1,opt,name=header_type,json=headerType,proto3,enum=neo.fs.v2.acl.HeaderType" json:"header_type,omitempty"`
	// Match operation type
	MatchType MatchType `protobuf:"varint,2,opt,name=match_type,json=matchType,proto3,enum=neo.fs.v2.acl.MatchType" json:"match_type,omitempty"`
	// Name of the Header to use
	HeaderName string `protobuf:"bytes,3,opt,name=header_name,json=headerName,proto3" json:"header_name,omitempty"`
	// Expected Header Value or pattern to match
	HeaderVal            string   `protobuf:"bytes,4,opt,name=header_val,json=value,proto3" json:"header_val,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EACLRecord_Filter) Reset()         { *m = EACLRecord_Filter{} }
func (m *EACLRecord_Filter) String() string { return proto.CompactTextString(m) }
func (*EACLRecord_Filter) ProtoMessage()    {}
func (*EACLRecord_Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{0, 0}
}
func (m *EACLRecord_Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EACLRecord_Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EACLRecord_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EACLRecord_Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EACLRecord_Filter.Merge(m, src)
}
func (m *EACLRecord_Filter) XXX_Size() int {
	return m.Size()
}
func (m *EACLRecord_Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_EACLRecord_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_EACLRecord_Filter proto.InternalMessageInfo

func (m *EACLRecord_Filter) GetHeaderType() HeaderType {
	if m != nil {
		return m.HeaderType
	}
	return HeaderType_HEADER_UNSPECIFIED
}

func (m *EACLRecord_Filter) GetMatchType() MatchType {
	if m != nil {
		return m.MatchType
	}
	return MatchType_MATCH_TYPE_UNSPECIFIED
}

func (m *EACLRecord_Filter) GetHeaderName() string {
	if m != nil {
		return m.HeaderName
	}
	return ""
}

func (m *EACLRecord_Filter) GetHeaderVal() string {
	if m != nil {
		return m.HeaderVal
	}
	return ""
}

// Target to apply ACL rule. Can be a subject's role class or a list of public
// keys to match.
type EACLRecord_Target struct {
	// Target subject's role class
	Role Role `protobuf:"varint,1,opt,name=role,proto3,enum=neo.fs.v2.acl.Role" json:"role,omitempty"`
	// List of public keys to identify target subject
	Keys                 [][]byte `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EACLRecord_Target) Reset()         { *m = EACLRecord_Target{} }
func (m *EACLRecord_Target) String() string { return proto.CompactTextString(m) }
func (*EACLRecord_Target) ProtoMessage()    {}
func (*EACLRecord_Target) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{0, 1}
}
func (m *EACLRecord_Target) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EACLRecord_Target) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EACLRecord_Target.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EACLRecord_Target) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EACLRecord_Target.Merge(m, src)
}
func (m *EACLRecord_Target) XXX_Size() int {
	return m.Size()
}
func (m *EACLRecord_Target) XXX_DiscardUnknown() {
	xxx_messageInfo_EACLRecord_Target.DiscardUnknown(m)
}

var xxx_messageInfo_EACLRecord_Target proto.InternalMessageInfo

func (m *EACLRecord_Target) GetRole() Role {
	if m != nil {
		return m.Role
	}
	return Role_ROLE_UNSPECIFIED
}

func (m *EACLRecord_Target) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

// Extended ACL rules table. Defined a list of ACL rules additionally to Basic
// ACL. Extended ACL rules can be attached to the container and can be updated
// or may be defined in `BearerToken` structure. Please see the corresponding
// NeoFS Technical Specification's section for detailed description.
type EACLTable struct {
	// eACL format version. Effectively the version of API library used to create
	// eACL Table.
	Version *grpc.Version `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Identifier of the container that should use given access control rules
	ContainerId *grpc.ContainerID `protobuf:"bytes,2,opt,name=container_id,json=containerID,proto3" json:"container_id,omitempty"`
	// List of Extended ACL rules
	Records              []*EACLRecord `protobuf:"bytes,3,rep,name=records,proto3" json:"records,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *EACLTable) Reset()         { *m = EACLTable{} }
func (m *EACLTable) String() string { return proto.CompactTextString(m) }
func (*EACLTable) ProtoMessage()    {}
func (*EACLTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{1}
}
func (m *EACLTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EACLTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EACLTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EACLTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EACLTable.Merge(m, src)
}
func (m *EACLTable) XXX_Size() int {
	return m.Size()
}
func (m *EACLTable) XXX_DiscardUnknown() {
	xxx_messageInfo_EACLTable.DiscardUnknown(m)
}

var xxx_messageInfo_EACLTable proto.InternalMessageInfo

func (m *EACLTable) GetVersion() *grpc.Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *EACLTable) GetContainerId() *grpc.ContainerID {
	if m != nil {
		return m.ContainerId
	}
	return nil
}

func (m *EACLTable) GetRecords() []*EACLRecord {
	if m != nil {
		return m.Records
	}
	return nil
}

// BearerToken allows to attach signed Extended ACL rules to the request in
// `RequestMetaHeader`. If container's Basic ACL rules allow, the attached rule
// set will be checked instead of one attached to the container itself. Just
// like [JWT](https://jwt.io), it has a limited lifetime and scope, hence can be
// used in the similar use cases, like providing authorisation to externally
// authenticated party.
type BearerToken struct {
	// Bearer Token body
	Body *BearerToken_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Signature of BearerToken body
	Signature            *grpc.Signature `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *BearerToken) Reset()         { *m = BearerToken{} }
func (m *BearerToken) String() string { return proto.CompactTextString(m) }
func (*BearerToken) ProtoMessage()    {}
func (*BearerToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{2}
}
func (m *BearerToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BearerToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BearerToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BearerToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BearerToken.Merge(m, src)
}
func (m *BearerToken) XXX_Size() int {
	return m.Size()
}
func (m *BearerToken) XXX_DiscardUnknown() {
	xxx_messageInfo_BearerToken.DiscardUnknown(m)
}

var xxx_messageInfo_BearerToken proto.InternalMessageInfo

func (m *BearerToken) GetBody() *BearerToken_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *BearerToken) GetSignature() *grpc.Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

// Bearer Token body structure contains Extended ACL table issued by container
// owner with additional information preventing token's abuse.
type BearerToken_Body struct {
	// Table of Extended ACL rules to use instead of the ones attached to the
	// container
	EaclTable *EACLTable `protobuf:"bytes,1,opt,name=eacl_table,json=eaclTable,proto3" json:"eacl_table,omitempty"`
	// `OwnerID` to whom the token was issued. MUST match with the request
	// originator's `OwnerID`
	OwnerId *grpc.OwnerID `protobuf:"bytes,2,opt,name=owner_id,json=ownerID,proto3" json:"owner_id,omitempty"`
	// Token expiration and valid time period parameters
	Lifetime             *BearerToken_Body_TokenLifetime `protobuf:"bytes,3,opt,name=lifetime,proto3" json:"lifetime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *BearerToken_Body) Reset()         { *m = BearerToken_Body{} }
func (m *BearerToken_Body) String() string { return proto.CompactTextString(m) }
func (*BearerToken_Body) ProtoMessage()    {}
func (*BearerToken_Body) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{2, 0}
}
func (m *BearerToken_Body) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BearerToken_Body) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BearerToken_Body.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BearerToken_Body) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BearerToken_Body.Merge(m, src)
}
func (m *BearerToken_Body) XXX_Size() int {
	return m.Size()
}
func (m *BearerToken_Body) XXX_DiscardUnknown() {
	xxx_messageInfo_BearerToken_Body.DiscardUnknown(m)
}

var xxx_messageInfo_BearerToken_Body proto.InternalMessageInfo

func (m *BearerToken_Body) GetEaclTable() *EACLTable {
	if m != nil {
		return m.EaclTable
	}
	return nil
}

func (m *BearerToken_Body) GetOwnerId() *grpc.OwnerID {
	if m != nil {
		return m.OwnerId
	}
	return nil
}

func (m *BearerToken_Body) GetLifetime() *BearerToken_Body_TokenLifetime {
	if m != nil {
		return m.Lifetime
	}
	return nil
}

// Lifetime parameters of the token. Filed names taken from
// [rfc7519](https://tools.ietf.org/html/rfc7519).
type BearerToken_Body_TokenLifetime struct {
	// Expiration Epoch
	Exp uint64 `protobuf:"varint,1,opt,name=exp,proto3" json:"exp,omitempty"`
	// Not valid before Epoch
	Nbf uint64 `protobuf:"varint,2,opt,name=nbf,proto3" json:"nbf,omitempty"`
	// Issued at Epoch
	Iat                  uint64   `protobuf:"varint,3,opt,name=iat,proto3" json:"iat,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BearerToken_Body_TokenLifetime) Reset()         { *m = BearerToken_Body_TokenLifetime{} }
func (m *BearerToken_Body_TokenLifetime) String() string { return proto.CompactTextString(m) }
func (*BearerToken_Body_TokenLifetime) ProtoMessage()    {}
func (*BearerToken_Body_TokenLifetime) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{2, 0, 0}
}
func (m *BearerToken_Body_TokenLifetime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BearerToken_Body_TokenLifetime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BearerToken_Body_TokenLifetime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BearerToken_Body_TokenLifetime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BearerToken_Body_TokenLifetime.Merge(m, src)
}
func (m *BearerToken_Body_TokenLifetime) XXX_Size() int {
	return m.Size()
}
func (m *BearerToken_Body_TokenLifetime) XXX_DiscardUnknown() {
	xxx_messageInfo_BearerToken_Body_TokenLifetime.DiscardUnknown(m)
}

var xxx_messageInfo_BearerToken_Body_TokenLifetime proto.InternalMessageInfo

func (m *BearerToken_Body_TokenLifetime) GetExp() uint64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *BearerToken_Body_TokenLifetime) GetNbf() uint64 {
	if m != nil {
		return m.Nbf
	}
	return 0
}

func (m *BearerToken_Body_TokenLifetime) GetIat() uint64 {
	if m != nil {
		return m.Iat
	}
	return 0
}

func init() {
	proto.RegisterEnum("neo.fs.v2.acl.Role", Role_name, Role_value)
	proto.RegisterEnum("neo.fs.v2.acl.MatchType", MatchType_name, MatchType_value)
	proto.RegisterEnum("neo.fs.v2.acl.Operation", Operation_name, Operation_value)
	proto.RegisterEnum("neo.fs.v2.acl.Action", Action_name, Action_value)
	proto.RegisterEnum("neo.fs.v2.acl.HeaderType", HeaderType_name, HeaderType_value)
	proto.RegisterType((*EACLRecord)(nil), "neo.fs.v2.acl.EACLRecord")
	proto.RegisterType((*EACLRecord_Filter)(nil), "neo.fs.v2.acl.EACLRecord.Filter")
	proto.RegisterType((*EACLRecord_Target)(nil), "neo.fs.v2.acl.EACLRecord.Target")
	proto.RegisterType((*EACLTable)(nil), "neo.fs.v2.acl.EACLTable")
	proto.RegisterType((*BearerToken)(nil), "neo.fs.v2.acl.BearerToken")
	proto.RegisterType((*BearerToken_Body)(nil), "neo.fs.v2.acl.BearerToken.Body")
	proto.RegisterType((*BearerToken_Body_TokenLifetime)(nil), "neo.fs.v2.acl.BearerToken.Body.TokenLifetime")
}

func init() { proto.RegisterFile("v2/acl/grpc/types.proto", fileDescriptor_8233b6696fb3e24f) }

var fileDescriptor_8233b6696fb3e24f = []byte{
	// 865 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x55, 0xdd, 0x8e, 0xda, 0x46,
	0x14, 0x8e, 0x7f, 0x16, 0x96, 0xc3, 0xa6, 0xb2, 0xa6, 0x4d, 0x02, 0x54, 0xda, 0xa0, 0xbd, 0xe9,
	0x0a, 0x09, 0xa3, 0xb0, 0x6a, 0x23, 0xa5, 0x6a, 0x24, 0x03, 0xb3, 0x0b, 0x15, 0x8b, 0xc9, 0xd8,
	0xa4, 0xda, 0xde, 0xa0, 0xc1, 0x0c, 0xac, 0x15, 0x63, 0x23, 0xdb, 0x4b, 0x4a, 0x6f, 0xab, 0xbe,
	0x43, 0x9f, 0xa1, 0xb7, 0xbd, 0xea, 0x1b, 0xf4, 0xb2, 0x8f, 0x50, 0x6d, 0xef, 0xfb, 0x0c, 0xd5,
	0x8c, 0x6d, 0xd8, 0x75, 0x36, 0xca, 0xdd, 0x99, 0x39, 0xdf, 0x77, 0xce, 0x77, 0xbe, 0x19, 0x8f,
	0xe1, 0xd9, 0xa6, 0xdd, 0xa2, 0x8e, 0xd7, 0x5a, 0x86, 0x6b, 0xa7, 0x15, 0x6f, 0xd7, 0x2c, 0xd2,
	0xd7, 0x61, 0x10, 0x07, 0xe8, 0xb1, 0xcf, 0x02, 0x7d, 0x11, 0xe9, 0x9b, 0xb6, 0x4e, 0x1d, 0xaf,
	0x56, 0xd9, 0xb4, 0x5b, 0x21, 0x5b, 0x44, 0x1f, 0x00, 0x4f, 0xfe, 0x53, 0x00, 0xb0, 0xd1, 0x1d,
	0x12, 0xe6, 0x04, 0xe1, 0x1c, 0x7d, 0x03, 0xa5, 0x60, 0xcd, 0x42, 0x1a, 0xbb, 0x81, 0x5f, 0x91,
	0xea, 0xd2, 0xe9, 0x67, 0xed, 0x8a, 0x7e, 0xaf, 0x96, 0x6e, 0x66, 0x79, 0xb2, 0x87, 0xa2, 0x26,
	0x14, 0xa8, 0x23, 0x48, 0xb2, 0x20, 0x3d, 0xc9, 0x91, 0x0c, 0x91, 0x24, 0x29, 0x08, 0xbd, 0x82,
	0xe2, 0xc2, 0xf5, 0x62, 0x16, 0x46, 0x15, 0xa5, 0xae, 0x9c, 0x96, 0xdb, 0xf5, 0x1c, 0x7e, 0x2f,
	0x49, 0x3f, 0x17, 0x40, 0x92, 0x11, 0x38, 0x37, 0xa6, 0xe1, 0x92, 0xc5, 0x51, 0x45, 0xfd, 0x14,
	0xd7, 0x16, 0x40, 0x92, 0x11, 0x6a, 0x7f, 0x4a, 0x50, 0x48, 0xea, 0xa1, 0x57, 0x50, 0xbe, 0x66,
	0x74, 0xce, 0xc2, 0x29, 0xb7, 0x23, 0x9d, 0xb5, 0x9a, 0x2b, 0xd5, 0x17, 0x08, 0x7b, 0xbb, 0x66,
	0x04, 0xae, 0x77, 0x31, 0x7a, 0x09, 0xb0, 0xa2, 0xb1, 0x73, 0x9d, 0x50, 0xe5, 0x07, 0x6d, 0xba,
	0xe4, 0x00, 0xc1, 0x2c, 0xad, 0xb2, 0x10, 0x3d, 0xdf, 0x35, 0xf5, 0xe9, 0x8a, 0x55, 0x94, 0xba,
	0x74, 0x5a, 0xca, 0x2a, 0x8f, 0xe8, 0x8a, 0xa1, 0x2a, 0xa4, 0xab, 0xe9, 0x86, 0x7a, 0x15, 0x55,
	0xe4, 0x0f, 0x36, 0xd4, 0xbb, 0x61, 0x35, 0x0c, 0x85, 0x64, 0x1c, 0xf4, 0x15, 0xa8, 0x61, 0xe0,
	0x65, 0x9a, 0x3f, 0xcf, 0x35, 0x26, 0x81, 0xc7, 0x88, 0x00, 0x20, 0x04, 0xea, 0x3b, 0xb6, 0x8d,
	0x2a, 0x72, 0x5d, 0x39, 0x3d, 0x22, 0x22, 0x3e, 0xf9, 0x43, 0x82, 0x12, 0x77, 0xc8, 0xa6, 0x33,
	0x8f, 0xa1, 0x17, 0x50, 0xdc, 0xb0, 0x30, 0xca, 0x4e, 0xbb, 0xdc, 0x7e, 0x76, 0xa7, 0x1a, 0xbf,
	0x31, 0xfa, 0xdb, 0x24, 0x4d, 0x32, 0x1c, 0x7a, 0x0d, 0x47, 0x4e, 0xe0, 0xc7, 0xd4, 0xf5, 0x59,
	0x38, 0x75, 0xe7, 0x62, 0xfc, 0x72, 0xfb, 0xcb, 0x3c, 0xaf, 0x9b, 0x61, 0x06, 0x3d, 0x52, 0x76,
	0xf6, 0x0b, 0x74, 0x06, 0xc5, 0x50, 0x9c, 0x4e, 0x76, 0xf6, 0xd5, 0x8f, 0x9e, 0x1f, 0xc9, 0x90,
	0x27, 0xbf, 0x28, 0x50, 0xee, 0x30, 0x1a, 0xb2, 0xd0, 0x0e, 0xde, 0x31, 0x1f, 0x9d, 0x81, 0x3a,
	0x0b, 0xe6, 0xdb, 0x54, 0xf4, 0xf3, 0x5c, 0x85, 0x3b, 0x48, 0xbd, 0x13, 0xcc, 0xb7, 0x44, 0x80,
	0xd1, 0x4b, 0x28, 0x45, 0xee, 0xd2, 0xa7, 0xf1, 0x4d, 0xc8, 0x52, 0xd9, 0xd5, 0xbc, 0x6c, 0x2b,
	0x03, 0x90, 0x3d, 0xb6, 0xf6, 0xab, 0x0c, 0x6a, 0x27, 0xa9, 0x00, 0x8c, 0x3a, 0xde, 0x34, 0xe6,
	0xe6, 0xa5, 0xcd, 0x2b, 0x0f, 0xc8, 0x17, 0xe6, 0x92, 0x12, 0xc7, 0x26, 0x3e, 0xb7, 0xe1, 0x30,
	0x78, 0x7f, 0xcf, 0xb0, 0x0f, 0x8c, 0x36, 0xdf, 0x27, 0x66, 0x15, 0x83, 0x24, 0x40, 0x03, 0x38,
	0xf4, 0xdc, 0x05, 0x8b, 0xdd, 0xf4, 0xa6, 0x94, 0xdb, 0xcd, 0x4f, 0xcc, 0xa9, 0x8b, 0x70, 0x98,
	0x92, 0xc8, 0x8e, 0x5e, 0xc3, 0xf0, 0xf8, 0x5e, 0x0a, 0x69, 0xa0, 0xb0, 0x9f, 0xd6, 0x62, 0x02,
	0x95, 0xf0, 0x90, 0xef, 0xf8, 0xb3, 0x85, 0x10, 0xa7, 0x12, 0x1e, 0xf2, 0x1d, 0x97, 0xc6, 0xa2,
	0xb5, 0x4a, 0x78, 0xd8, 0x78, 0x0d, 0x2a, 0xbf, 0x5d, 0xe8, 0x0b, 0xd0, 0x88, 0x39, 0xc4, 0xd3,
	0xc9, 0xc8, 0x1a, 0xe3, 0xee, 0xe0, 0x7c, 0x80, 0x7b, 0xda, 0x23, 0x74, 0x08, 0xea, 0xc4, 0xc2,
	0x44, 0x93, 0x10, 0x40, 0xc1, 0xba, 0xb2, 0x6c, 0x7c, 0xa9, 0xc9, 0x3c, 0x36, 0xed, 0x3e, 0x26,
	0x96, 0xa6, 0x34, 0x4c, 0x28, 0xed, 0x3e, 0x0b, 0x54, 0x83, 0xa7, 0x97, 0x86, 0xdd, 0xed, 0x4f,
	0xed, 0xab, 0x71, 0xbe, 0x94, 0x06, 0x47, 0x96, 0x4d, 0x06, 0xa3, 0x8b, 0x29, 0x7e, 0x33, 0x31,
	0x86, 0x9a, 0xc4, 0x5b, 0xa6, 0x3b, 0x23, 0xd3, 0x4e, 0x77, 0xe5, 0xc6, 0xcf, 0x50, 0xda, 0x3d,
	0x47, 0xa8, 0x0a, 0x4f, 0xcc, 0x31, 0x26, 0x86, 0x3d, 0x30, 0x47, 0xb9, 0x7a, 0x45, 0x50, 0x2e,
	0xb0, 0xad, 0x49, 0x5c, 0x63, 0x1f, 0x1b, 0x3d, 0x4d, 0xe6, 0x5b, 0xe3, 0x89, 0xad, 0x29, 0x5c,
	0x60, 0x0f, 0x0f, 0xb1, 0x8d, 0x35, 0x55, 0x08, 0xc7, 0x06, 0xe9, 0xf6, 0xb5, 0x03, 0x74, 0x04,
	0x87, 0x17, 0xd8, 0x26, 0xc6, 0xe8, 0x02, 0x6b, 0x05, 0xae, 0x28, 0x5b, 0xf5, 0x0d, 0xab, 0xaf,
	0x15, 0x1b, 0x5f, 0x43, 0x21, 0x79, 0xd5, 0xd0, 0x53, 0x40, 0x46, 0xf7, 0x81, 0xae, 0x25, 0x38,
	0x30, 0x86, 0x43, 0xf3, 0x87, 0xa4, 0x6f, 0x0f, 0x8f, 0xae, 0x34, 0xb9, 0xf1, 0x1d, 0xc0, 0xfe,
	0x55, 0xe1, 0x54, 0xae, 0x07, 0x93, 0x1c, 0xb5, 0x0c, 0x45, 0x82, 0xdf, 0x4c, 0xb0, 0x65, 0x27,
	0x76, 0x9a, 0x9d, 0xef, 0x71, 0xd7, 0xd6, 0xe4, 0xce, 0xdb, 0xbf, 0x6e, 0x8f, 0xa5, 0xbf, 0x6f,
	0x8f, 0xa5, 0x7f, 0x6e, 0x8f, 0xa5, 0xdf, 0xfe, 0x3d, 0x7e, 0xf4, 0xe3, 0x8b, 0xa5, 0x1b, 0x5f,
	0xdf, 0xcc, 0x74, 0x27, 0x58, 0xb5, 0xfc, 0x68, 0xed, 0x38, 0xcd, 0x39, 0xdb, 0xb4, 0x7c, 0x16,
	0x2c, 0xa2, 0x26, 0x5d, 0xbb, 0xcd, 0x65, 0xd0, 0xba, 0xf3, 0x97, 0xf8, 0x96, 0x3a, 0xde, 0xef,
	0xb2, 0x36, 0x62, 0xc1, 0xb9, 0xa5, 0x1b, 0xe3, 0x01, 0xbf, 0x4a, 0x86, 0xe3, 0xcd, 0x0a, 0xe2,
	0x77, 0x70, 0xf6, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x54, 0x26, 0xa8, 0x52, 0x06, 0x00,
	0x00,
}

func (m *EACLRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EACLRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EACLRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Targets) > 0 {
		for iNdEx := len(m.Targets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Targets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Action != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x10
	}
	if m.Operation != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EACLRecord_Filter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EACLRecord_Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EACLRecord_Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.HeaderVal) > 0 {
		i -= len(m.HeaderVal)
		copy(dAtA[i:], m.HeaderVal)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HeaderVal)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.HeaderName) > 0 {
		i -= len(m.HeaderName)
		copy(dAtA[i:], m.HeaderName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HeaderName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MatchType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MatchType))
		i--
		dAtA[i] = 0x10
	}
	if m.HeaderType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.HeaderType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EACLRecord_Target) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EACLRecord_Target) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EACLRecord_Target) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Role != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EACLTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EACLTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EACLTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ContainerId != nil {
		{
			size, err := m.ContainerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BearerToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BearerToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BearerToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BearerToken_Body) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BearerToken_Body) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BearerToken_Body) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Lifetime != nil {
		{
			size, err := m.Lifetime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.OwnerId != nil {
		{
			size, err := m.OwnerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.EaclTable != nil {
		{
			size, err := m.EaclTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BearerToken_Body_TokenLifetime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BearerToken_Body_TokenLifetime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BearerToken_Body_TokenLifetime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Iat != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Iat))
		i--
		dAtA[i] = 0x18
	}
	if m.Nbf != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Nbf))
		i--
		dAtA[i] = 0x10
	}
	if m.Exp != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Exp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EACLRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != 0 {
		n += 1 + sovTypes(uint64(m.Operation))
	}
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EACLRecord_Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeaderType != 0 {
		n += 1 + sovTypes(uint64(m.HeaderType))
	}
	if m.MatchType != 0 {
		n += 1 + sovTypes(uint64(m.MatchType))
	}
	l = len(m.HeaderName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HeaderVal)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EACLRecord_Target) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Role != 0 {
		n += 1 + sovTypes(uint64(m.Role))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EACLTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ContainerId != nil {
		l = m.ContainerId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BearerToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BearerToken_Body) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EaclTable != nil {
		l = m.EaclTable.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OwnerId != nil {
		l = m.OwnerId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Lifetime != nil {
		l = m.Lifetime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BearerToken_Body_TokenLifetime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exp != 0 {
		n += 1 + sovTypes(uint64(m.Exp))
	}
	if m.Nbf != 0 {
		n += 1 + sovTypes(uint64(m.Nbf))
	}
	if m.Iat != 0 {
		n += 1 + sovTypes(uint64(m.Iat))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EACLRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EACLRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EACLRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= Operation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= Action(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &EACLRecord_Filter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, &EACLRecord_Target{})
			if err := m.Targets[len(m.Targets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EACLRecord_Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderType", wireType)
			}
			m.HeaderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeaderType |= HeaderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchType", wireType)
			}
			m.MatchType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchType |= MatchType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderVal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderVal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EACLRecord_Target) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Target: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Target: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= Role(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EACLTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EACLTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EACLTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &grpc.Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerId == nil {
				m.ContainerId = &grpc.ContainerID{}
			}
			if err := m.ContainerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &EACLRecord{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BearerToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BearerToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &BearerToken_Body{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &grpc.Signature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerToken_Body) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Body: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Body: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EaclTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EaclTable == nil {
				m.EaclTable = &EACLTable{}
			}
			if err := m.EaclTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerId == nil {
				m.OwnerId = &grpc.OwnerID{}
			}
			if err := m.OwnerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lifetime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lifetime == nil {
				m.Lifetime = &BearerToken_Body_TokenLifetime{}
			}
			if err := m.Lifetime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerToken_Body_TokenLifetime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenLifetime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenLifetime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nbf", wireType)
			}
			m.Nbf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nbf |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iat", wireType)
			}
			m.Iat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Iat |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
