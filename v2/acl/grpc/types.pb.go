// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v2/acl/grpc/types.proto

package acl

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "github.com/nspcc-dev/neofs-api-go/v2/refs/grpc"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Target role of the access control rule in access control list.
type Role int32

const (
	// Unspecified  role, default value.
	Role_ROLE_UNSPECIFIED Role = 0
	// User target rule is applied if sender is the owner of the container.
	Role_USER Role = 1
	// System target rule is applied if sender is the storage node within the
	// container or inner ring node.
	Role_SYSTEM Role = 2
	// Others target rule is applied if sender is not user or system target.
	Role_OTHERS Role = 3
)

var Role_name = map[int32]string{
	0: "ROLE_UNSPECIFIED",
	1: "USER",
	2: "SYSTEM",
	3: "OTHERS",
}

var Role_value = map[string]int32{
	"ROLE_UNSPECIFIED": 0,
	"USER":             1,
	"SYSTEM":           2,
	"OTHERS":           3,
}

func (x Role) String() string {
	return proto.EnumName(Role_name, int32(x))
}

func (Role) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{0}
}

// MatchType is an enumeration of match types.
type MatchType int32

const (
	// Unspecified match type, default value.
	MatchType_MATCH_TYPE_UNSPECIFIED MatchType = 0
	// Return true if strings are equal
	MatchType_STRING_EQUAL MatchType = 1
	// Return true if strings are different
	MatchType_STRING_NOT_EQUAL MatchType = 2
)

var MatchType_name = map[int32]string{
	0: "MATCH_TYPE_UNSPECIFIED",
	1: "STRING_EQUAL",
	2: "STRING_NOT_EQUAL",
}

var MatchType_value = map[string]int32{
	"MATCH_TYPE_UNSPECIFIED": 0,
	"STRING_EQUAL":           1,
	"STRING_NOT_EQUAL":       2,
}

func (x MatchType) String() string {
	return proto.EnumName(MatchType_name, int32(x))
}

func (MatchType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{1}
}

// Operation is an enumeration of operation types.
type Operation int32

const (
	// Unspecified operation, default value.
	Operation_OPERATION_UNSPECIFIED Operation = 0
	// Get
	Operation_GET Operation = 1
	// Head
	Operation_HEAD Operation = 2
	// Put
	Operation_PUT Operation = 3
	// Delete
	Operation_DELETE Operation = 4
	// Search
	Operation_SEARCH Operation = 5
	// GetRange
	Operation_GETRANGE Operation = 6
	// GetRangeHash
	Operation_GETRANGEHASH Operation = 7
)

var Operation_name = map[int32]string{
	0: "OPERATION_UNSPECIFIED",
	1: "GET",
	2: "HEAD",
	3: "PUT",
	4: "DELETE",
	5: "SEARCH",
	6: "GETRANGE",
	7: "GETRANGEHASH",
}

var Operation_value = map[string]int32{
	"OPERATION_UNSPECIFIED": 0,
	"GET":                   1,
	"HEAD":                  2,
	"PUT":                   3,
	"DELETE":                4,
	"SEARCH":                5,
	"GETRANGE":              6,
	"GETRANGEHASH":          7,
}

func (x Operation) String() string {
	return proto.EnumName(Operation_name, int32(x))
}

func (Operation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{2}
}

// Action is an enumeration of EACL actions.
type Action int32

const (
	// Unspecified action, default value.
	Action_ACTION_UNSPECIFIED Action = 0
	// Allow action
	Action_ALLOW Action = 1
	// Deny action
	Action_DENY Action = 2
)

var Action_name = map[int32]string{
	0: "ACTION_UNSPECIFIED",
	1: "ALLOW",
	2: "DENY",
}

var Action_value = map[string]int32{
	"ACTION_UNSPECIFIED": 0,
	"ALLOW":              1,
	"DENY":               2,
}

func (x Action) String() string {
	return proto.EnumName(Action_name, int32(x))
}

func (Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{3}
}

// Header is an enumeration of filtering header types.
type HeaderType int32

const (
	// Unspecified header, default value.
	HeaderType_HEADER_UNSPECIFIED HeaderType = 0
	// Filter request headers
	HeaderType_REQUEST HeaderType = 1
	// Filter object headers
	HeaderType_OBJECT HeaderType = 2
)

var HeaderType_name = map[int32]string{
	0: "HEADER_UNSPECIFIED",
	1: "REQUEST",
	2: "OBJECT",
}

var HeaderType_value = map[string]int32{
	"HEADER_UNSPECIFIED": 0,
	"REQUEST":            1,
	"OBJECT":             2,
}

func (x HeaderType) String() string {
	return proto.EnumName(HeaderType_name, int32(x))
}

func (HeaderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{4}
}

// EACLRecord groups information about extended ACL rule.
type EACLRecord struct {
	// Operation carries type of operation.
	Operation Operation `protobuf:"varint,1,opt,name=operation,json=Operation,proto3,enum=neo.fs.v2.acl.Operation" json:"operation,omitempty"`
	// Action carries ACL target action.
	Action Action `protobuf:"varint,2,opt,name=action,json=Action,proto3,enum=neo.fs.v2.acl.Action" json:"action,omitempty"`
	// filters carries set of filters.
	Filters []*EACLRecord_Filter `protobuf:"bytes,3,rep,name=filters,json=Filters,proto3" json:"filters,omitempty"`
	// targets carries information about extended ACL target list.
	Targets              []*EACLRecord_Target `protobuf:"bytes,4,rep,name=targets,json=Targets,proto3" json:"targets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *EACLRecord) Reset()         { *m = EACLRecord{} }
func (m *EACLRecord) String() string { return proto.CompactTextString(m) }
func (*EACLRecord) ProtoMessage()    {}
func (*EACLRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{0}
}
func (m *EACLRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EACLRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EACLRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EACLRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EACLRecord.Merge(m, src)
}
func (m *EACLRecord) XXX_Size() int {
	return m.Size()
}
func (m *EACLRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_EACLRecord.DiscardUnknown(m)
}

var xxx_messageInfo_EACLRecord proto.InternalMessageInfo

func (m *EACLRecord) GetOperation() Operation {
	if m != nil {
		return m.Operation
	}
	return Operation_OPERATION_UNSPECIFIED
}

func (m *EACLRecord) GetAction() Action {
	if m != nil {
		return m.Action
	}
	return Action_ACTION_UNSPECIFIED
}

func (m *EACLRecord) GetFilters() []*EACLRecord_Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *EACLRecord) GetTargets() []*EACLRecord_Target {
	if m != nil {
		return m.Targets
	}
	return nil
}

// Filter definition
type EACLRecord_Filter struct {
	// Header carries type of header.
	HeaderType HeaderType `protobuf:"varint,1,opt,name=header_type,json=HeaderType,proto3,enum=neo.fs.v2.acl.HeaderType" json:"header_type,omitempty"`
	// MatchType carries type of match.
	MatchType MatchType `protobuf:"varint,2,opt,name=match_type,json=MatchType,proto3,enum=neo.fs.v2.acl.MatchType" json:"match_type,omitempty"`
	// header_name carries name of filtering header.
	HeaderName string `protobuf:"bytes,3,opt,name=header_name,json=Name,proto3" json:"header_name,omitempty"`
	// header_val carries value of filtering header.
	HeaderVal            string   `protobuf:"bytes,4,opt,name=header_val,json=Value,proto3" json:"header_val,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EACLRecord_Filter) Reset()         { *m = EACLRecord_Filter{} }
func (m *EACLRecord_Filter) String() string { return proto.CompactTextString(m) }
func (*EACLRecord_Filter) ProtoMessage()    {}
func (*EACLRecord_Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{0, 0}
}
func (m *EACLRecord_Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EACLRecord_Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EACLRecord_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EACLRecord_Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EACLRecord_Filter.Merge(m, src)
}
func (m *EACLRecord_Filter) XXX_Size() int {
	return m.Size()
}
func (m *EACLRecord_Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_EACLRecord_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_EACLRecord_Filter proto.InternalMessageInfo

func (m *EACLRecord_Filter) GetHeaderType() HeaderType {
	if m != nil {
		return m.HeaderType
	}
	return HeaderType_HEADER_UNSPECIFIED
}

func (m *EACLRecord_Filter) GetMatchType() MatchType {
	if m != nil {
		return m.MatchType
	}
	return MatchType_MATCH_TYPE_UNSPECIFIED
}

func (m *EACLRecord_Filter) GetHeaderName() string {
	if m != nil {
		return m.HeaderName
	}
	return ""
}

func (m *EACLRecord_Filter) GetHeaderVal() string {
	if m != nil {
		return m.HeaderVal
	}
	return ""
}

// Information about extended ACL target.
type EACLRecord_Target struct {
	// target carries target of ACL rule.
	Role Role `protobuf:"varint,1,opt,name=role,json=Role,proto3,enum=neo.fs.v2.acl.Role" json:"role,omitempty"`
	// key_list carries public keys of ACL target.
	KeyList              [][]byte `protobuf:"bytes,2,rep,name=key_list,json=Keys,proto3" json:"key_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EACLRecord_Target) Reset()         { *m = EACLRecord_Target{} }
func (m *EACLRecord_Target) String() string { return proto.CompactTextString(m) }
func (*EACLRecord_Target) ProtoMessage()    {}
func (*EACLRecord_Target) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{0, 1}
}
func (m *EACLRecord_Target) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EACLRecord_Target) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EACLRecord_Target.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EACLRecord_Target) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EACLRecord_Target.Merge(m, src)
}
func (m *EACLRecord_Target) XXX_Size() int {
	return m.Size()
}
func (m *EACLRecord_Target) XXX_DiscardUnknown() {
	xxx_messageInfo_EACLRecord_Target.DiscardUnknown(m)
}

var xxx_messageInfo_EACLRecord_Target proto.InternalMessageInfo

func (m *EACLRecord_Target) GetRole() Role {
	if m != nil {
		return m.Role
	}
	return Role_ROLE_UNSPECIFIED
}

func (m *EACLRecord_Target) GetKeyList() [][]byte {
	if m != nil {
		return m.KeyList
	}
	return nil
}

// EACLRecord carries the information about extended ACL rules.
type EACLTable struct {
	// eACL format version.
	// Effectively the version of API library used to create eACL Table
	Version *grpc.Version `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Carries identifier of the container that should use given
	// access control rules.
	ContainerId *grpc.ContainerID `protobuf:"bytes,2,opt,name=container_id,json=ContainerID,proto3" json:"container_id,omitempty"`
	// Records carries list of extended ACL rule records.
	Records              []*EACLRecord `protobuf:"bytes,3,rep,name=records,json=Records,proto3" json:"records,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *EACLTable) Reset()         { *m = EACLTable{} }
func (m *EACLTable) String() string { return proto.CompactTextString(m) }
func (*EACLTable) ProtoMessage()    {}
func (*EACLTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{1}
}
func (m *EACLTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EACLTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EACLTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EACLTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EACLTable.Merge(m, src)
}
func (m *EACLTable) XXX_Size() int {
	return m.Size()
}
func (m *EACLTable) XXX_DiscardUnknown() {
	xxx_messageInfo_EACLTable.DiscardUnknown(m)
}

var xxx_messageInfo_EACLTable proto.InternalMessageInfo

func (m *EACLTable) GetVersion() *grpc.Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *EACLTable) GetContainerId() *grpc.ContainerID {
	if m != nil {
		return m.ContainerId
	}
	return nil
}

func (m *EACLTable) GetRecords() []*EACLRecord {
	if m != nil {
		return m.Records
	}
	return nil
}

// BearerToken has information about request ACL rules with limited lifetime
type BearerToken struct {
	// Bearer Token body
	Body *BearerToken_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Signature of BearerToken body
	Signature            *grpc.Signature `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *BearerToken) Reset()         { *m = BearerToken{} }
func (m *BearerToken) String() string { return proto.CompactTextString(m) }
func (*BearerToken) ProtoMessage()    {}
func (*BearerToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{2}
}
func (m *BearerToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BearerToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BearerToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BearerToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BearerToken.Merge(m, src)
}
func (m *BearerToken) XXX_Size() int {
	return m.Size()
}
func (m *BearerToken) XXX_DiscardUnknown() {
	xxx_messageInfo_BearerToken.DiscardUnknown(m)
}

var xxx_messageInfo_BearerToken proto.InternalMessageInfo

func (m *BearerToken) GetBody() *BearerToken_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *BearerToken) GetSignature() *grpc.Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

// Bearer Token body
type BearerToken_Body struct {
	// EACLTable carries table of extended ACL rules
	EaclTable *EACLTable `protobuf:"bytes,1,opt,name=eacl_table,json=eaclTable,proto3" json:"eacl_table,omitempty"`
	// OwnerID carries identifier of the token owner
	OwnerId *grpc.OwnerID `protobuf:"bytes,2,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	// Token expiration and valid time period parameters
	Lifetime             *BearerToken_Body_TokenLifetime `protobuf:"bytes,3,opt,name=lifetime,proto3" json:"lifetime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *BearerToken_Body) Reset()         { *m = BearerToken_Body{} }
func (m *BearerToken_Body) String() string { return proto.CompactTextString(m) }
func (*BearerToken_Body) ProtoMessage()    {}
func (*BearerToken_Body) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{2, 0}
}
func (m *BearerToken_Body) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BearerToken_Body) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BearerToken_Body.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BearerToken_Body) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BearerToken_Body.Merge(m, src)
}
func (m *BearerToken_Body) XXX_Size() int {
	return m.Size()
}
func (m *BearerToken_Body) XXX_DiscardUnknown() {
	xxx_messageInfo_BearerToken_Body.DiscardUnknown(m)
}

var xxx_messageInfo_BearerToken_Body proto.InternalMessageInfo

func (m *BearerToken_Body) GetEaclTable() *EACLTable {
	if m != nil {
		return m.EaclTable
	}
	return nil
}

func (m *BearerToken_Body) GetOwnerId() *grpc.OwnerID {
	if m != nil {
		return m.OwnerId
	}
	return nil
}

func (m *BearerToken_Body) GetLifetime() *BearerToken_Body_TokenLifetime {
	if m != nil {
		return m.Lifetime
	}
	return nil
}

// Lifetime parameters of the token. Filed names taken from rfc7519.
type BearerToken_Body_TokenLifetime struct {
	// Expiration Epoch
	Exp uint64 `protobuf:"varint,1,opt,name=exp,proto3" json:"exp,omitempty"`
	// Not valid before Epoch
	Nbf uint64 `protobuf:"varint,2,opt,name=nbf,proto3" json:"nbf,omitempty"`
	// Issued at Epoch
	Iat                  uint64   `protobuf:"varint,3,opt,name=iat,proto3" json:"iat,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BearerToken_Body_TokenLifetime) Reset()         { *m = BearerToken_Body_TokenLifetime{} }
func (m *BearerToken_Body_TokenLifetime) String() string { return proto.CompactTextString(m) }
func (*BearerToken_Body_TokenLifetime) ProtoMessage()    {}
func (*BearerToken_Body_TokenLifetime) Descriptor() ([]byte, []int) {
	return fileDescriptor_8233b6696fb3e24f, []int{2, 0, 0}
}
func (m *BearerToken_Body_TokenLifetime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BearerToken_Body_TokenLifetime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BearerToken_Body_TokenLifetime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BearerToken_Body_TokenLifetime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BearerToken_Body_TokenLifetime.Merge(m, src)
}
func (m *BearerToken_Body_TokenLifetime) XXX_Size() int {
	return m.Size()
}
func (m *BearerToken_Body_TokenLifetime) XXX_DiscardUnknown() {
	xxx_messageInfo_BearerToken_Body_TokenLifetime.DiscardUnknown(m)
}

var xxx_messageInfo_BearerToken_Body_TokenLifetime proto.InternalMessageInfo

func (m *BearerToken_Body_TokenLifetime) GetExp() uint64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *BearerToken_Body_TokenLifetime) GetNbf() uint64 {
	if m != nil {
		return m.Nbf
	}
	return 0
}

func (m *BearerToken_Body_TokenLifetime) GetIat() uint64 {
	if m != nil {
		return m.Iat
	}
	return 0
}

func init() {
	proto.RegisterEnum("neo.fs.v2.acl.Role", Role_name, Role_value)
	proto.RegisterEnum("neo.fs.v2.acl.MatchType", MatchType_name, MatchType_value)
	proto.RegisterEnum("neo.fs.v2.acl.Operation", Operation_name, Operation_value)
	proto.RegisterEnum("neo.fs.v2.acl.Action", Action_name, Action_value)
	proto.RegisterEnum("neo.fs.v2.acl.HeaderType", HeaderType_name, HeaderType_value)
	proto.RegisterType((*EACLRecord)(nil), "neo.fs.v2.acl.EACLRecord")
	proto.RegisterType((*EACLRecord_Filter)(nil), "neo.fs.v2.acl.EACLRecord.Filter")
	proto.RegisterType((*EACLRecord_Target)(nil), "neo.fs.v2.acl.EACLRecord.Target")
	proto.RegisterType((*EACLTable)(nil), "neo.fs.v2.acl.EACLTable")
	proto.RegisterType((*BearerToken)(nil), "neo.fs.v2.acl.BearerToken")
	proto.RegisterType((*BearerToken_Body)(nil), "neo.fs.v2.acl.BearerToken.Body")
	proto.RegisterType((*BearerToken_Body_TokenLifetime)(nil), "neo.fs.v2.acl.BearerToken.Body.TokenLifetime")
}

func init() { proto.RegisterFile("v2/acl/grpc/types.proto", fileDescriptor_8233b6696fb3e24f) }

var fileDescriptor_8233b6696fb3e24f = []byte{
	// 869 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x55, 0xdd, 0x6e, 0xe2, 0x46,
	0x14, 0x5e, 0xff, 0x04, 0xc3, 0x21, 0x5b, 0x59, 0xd3, 0x6e, 0x16, 0xa8, 0x94, 0xa2, 0xdc, 0x34,
	0x42, 0xc2, 0x68, 0x89, 0xda, 0x95, 0xb6, 0xea, 0x4a, 0x06, 0x26, 0x81, 0x96, 0x60, 0x76, 0x6c,
	0x52, 0xa5, 0x37, 0x68, 0x30, 0x03, 0xb1, 0xd6, 0xb1, 0x91, 0xed, 0xb0, 0xa5, 0xb7, 0x55, 0xdf,
	0xa1, 0xcf, 0xd0, 0xdb, 0x7d, 0x89, 0x5e, 0xf6, 0x11, 0xaa, 0xf4, 0xb6, 0x0f, 0x51, 0xcd, 0x18,
	0x27, 0xc4, 0x9b, 0xd5, 0xde, 0x30, 0xc7, 0x73, 0xbe, 0xef, 0x9c, 0xef, 0x7c, 0x33, 0xd8, 0xf0,
	0x7c, 0xdd, 0x6e, 0x51, 0xd7, 0x6f, 0x2d, 0xa3, 0x95, 0xdb, 0x4a, 0x36, 0x2b, 0x16, 0x1b, 0xab,
	0x28, 0x4c, 0x42, 0xf4, 0x34, 0x60, 0xa1, 0xb1, 0x88, 0x8d, 0x75, 0xdb, 0xa0, 0xae, 0x5f, 0xab,
	0xac, 0xdb, 0xad, 0x88, 0x2d, 0xe2, 0x0f, 0x80, 0x47, 0xff, 0x29, 0x00, 0xd8, 0xec, 0x0e, 0x09,
	0x73, 0xc3, 0x68, 0x8e, 0xbe, 0x85, 0x52, 0xb8, 0x62, 0x11, 0x4d, 0xbc, 0x30, 0xa8, 0x48, 0x75,
	0xe9, 0xf8, 0xb3, 0x76, 0xc5, 0x78, 0x50, 0xcb, 0xb0, 0xb2, 0x3c, 0x29, 0xdd, 0x85, 0xa8, 0x09,
	0x05, 0xea, 0x0a, 0x92, 0x2c, 0x48, 0xcf, 0x72, 0x24, 0x53, 0x24, 0x49, 0x21, 0x5d, 0xd1, 0x2b,
	0xd0, 0x16, 0x9e, 0x9f, 0xb0, 0x28, 0xae, 0x28, 0x75, 0xe5, 0xb8, 0xdc, 0xae, 0xe7, 0xf0, 0xf7,
	0x92, 0x8c, 0x53, 0x01, 0x24, 0x5a, 0xba, 0xc6, 0x9c, 0x9b, 0xd0, 0x68, 0xc9, 0x92, 0xb8, 0xa2,
	0x7e, 0x8a, 0xeb, 0x08, 0x20, 0xd1, 0xd2, 0x35, 0xae, 0xbd, 0x97, 0xa0, 0x90, 0xd6, 0x41, 0xaf,
	0xa0, 0x7c, 0xc5, 0xe8, 0x9c, 0x45, 0x53, 0x6e, 0xc7, 0x76, 0xd6, 0x6a, 0xae, 0x54, 0x5f, 0x20,
	0x9c, 0xcd, 0x8a, 0x11, 0xb8, 0x8f, 0xd1, 0x4b, 0x80, 0x6b, 0x9a, 0xb8, 0x57, 0x29, 0x55, 0x7e,
	0xd4, 0xa6, 0x73, 0x0e, 0x10, 0xcc, 0xd2, 0x5d, 0x88, 0xaa, 0x77, 0x4d, 0x03, 0x7a, 0xcd, 0x2a,
	0x4a, 0x5d, 0x3a, 0x2e, 0x11, 0x75, 0x44, 0xaf, 0x79, 0x0a, 0xb6, 0xa9, 0x35, 0xf5, 0x2b, 0xaa,
	0xc8, 0xec, 0x5d, 0x50, 0xff, 0x86, 0xd5, 0x06, 0x50, 0x48, 0x07, 0x40, 0x5f, 0x83, 0x1a, 0x85,
	0x7e, 0xa6, 0xf6, 0xf3, 0x5c, 0x4b, 0x12, 0xfa, 0x8c, 0xa8, 0xfc, 0x17, 0x1d, 0x40, 0xf1, 0x2d,
	0xdb, 0x4c, 0x7d, 0x2f, 0x4e, 0x2a, 0x72, 0x5d, 0x39, 0xde, 0x27, 0xea, 0x8f, 0x6c, 0x13, 0x1f,
	0xbd, 0x97, 0xa0, 0xc4, 0xfd, 0x71, 0xe8, 0xcc, 0x67, 0xe8, 0x05, 0x68, 0x6b, 0x16, 0xc5, 0xd9,
	0x59, 0x97, 0xdb, 0xcf, 0x77, 0x2a, 0xf2, 0xfb, 0x62, 0x5c, 0xa4, 0x69, 0x92, 0xe1, 0xd0, 0x6b,
	0xd8, 0x77, 0xc3, 0x20, 0xa1, 0x5e, 0xc0, 0xa2, 0xa9, 0x37, 0x17, 0xc3, 0x97, 0xdb, 0x5f, 0xe6,
	0x79, 0xdd, 0x0c, 0x33, 0xe8, 0x91, 0xf2, 0xce, 0x03, 0x3a, 0x01, 0x2d, 0x12, 0x67, 0x93, 0x9d,
	0x7c, 0xf5, 0xa3, 0xa7, 0x47, 0xb4, 0x74, 0x8d, 0x8f, 0x7e, 0x53, 0xa0, 0xdc, 0x61, 0x34, 0x62,
	0x91, 0x13, 0xbe, 0x65, 0x01, 0x3a, 0x01, 0x75, 0x16, 0xce, 0x37, 0x5b, 0xd1, 0x5f, 0xe5, 0x2a,
	0xec, 0x20, 0x8d, 0x4e, 0x38, 0xdf, 0x10, 0x01, 0x46, 0x2f, 0xa1, 0x14, 0x7b, 0xcb, 0x80, 0x26,
	0x37, 0x11, 0xdb, 0xca, 0xae, 0xe6, 0x65, 0xdb, 0x19, 0x80, 0xdc, 0x63, 0x6b, 0xbf, 0xcb, 0xa0,
	0x76, 0xd2, 0x0a, 0xc0, 0xa8, 0xeb, 0x4f, 0x13, 0x6e, 0xde, 0xb6, 0x79, 0xe5, 0x11, 0xf9, 0xc2,
	0x5c, 0x52, 0xe2, 0xd8, 0xd4, 0xe7, 0x36, 0x14, 0xc3, 0x77, 0x0f, 0x0c, 0xfb, 0xc0, 0x68, 0xeb,
	0x5d, 0x6a, 0x96, 0x26, 0x80, 0x83, 0x39, 0x1a, 0x40, 0xd1, 0xf7, 0x16, 0x2c, 0xf1, 0xb6, 0xf7,
	0xa4, 0xdc, 0x6e, 0x7e, 0x62, 0x4e, 0x43, 0x84, 0xc3, 0x2d, 0x89, 0xdc, 0xd1, 0x6b, 0x18, 0x9e,
	0x3e, 0x48, 0x21, 0x1d, 0x14, 0xf6, 0xcb, 0x4a, 0x4c, 0xa0, 0x12, 0x1e, 0xf2, 0x9d, 0x60, 0xb6,
	0x10, 0xe2, 0x54, 0xc2, 0x43, 0xbe, 0xe3, 0xd1, 0x44, 0xb4, 0x56, 0x09, 0x0f, 0x1b, 0xaf, 0x21,
	0xbd, 0x5b, 0x5f, 0x80, 0x4e, 0xac, 0x21, 0x9e, 0x4e, 0x46, 0xf6, 0x18, 0x77, 0x07, 0xa7, 0x03,
	0xdc, 0xd3, 0x9f, 0xa0, 0x22, 0xa8, 0x13, 0x1b, 0x13, 0x5d, 0x42, 0x00, 0x05, 0xfb, 0xd2, 0x76,
	0xf0, 0xb9, 0x2e, 0xf3, 0xd8, 0x72, 0xfa, 0x98, 0xd8, 0xba, 0xd2, 0xb0, 0x60, 0xe7, 0x9f, 0x50,
	0x83, 0x83, 0x73, 0xd3, 0xe9, 0xf6, 0xa7, 0xce, 0xe5, 0x38, 0x5f, 0x4a, 0x87, 0x7d, 0xdb, 0x21,
	0x83, 0xd1, 0xd9, 0x14, 0xbf, 0x99, 0x98, 0x43, 0x5d, 0xe2, 0x2d, 0xb7, 0x3b, 0x23, 0xcb, 0xd9,
	0xee, 0xca, 0x8d, 0x5f, 0x61, 0xe7, 0x0d, 0x54, 0x85, 0x67, 0xd6, 0x18, 0x13, 0xd3, 0x19, 0x58,
	0xa3, 0x5c, 0x3d, 0x0d, 0x94, 0x33, 0xec, 0xe8, 0x12, 0xd7, 0xd8, 0xc7, 0x66, 0x4f, 0x97, 0xf9,
	0xd6, 0x78, 0xe2, 0xe8, 0x0a, 0x17, 0xd8, 0xc3, 0x43, 0xec, 0x60, 0x5d, 0x15, 0xc2, 0xb1, 0x49,
	0xba, 0x7d, 0x7d, 0x0f, 0xed, 0x43, 0xf1, 0x0c, 0x3b, 0xc4, 0x1c, 0x9d, 0x61, 0xbd, 0xc0, 0x15,
	0x65, 0x4f, 0x7d, 0xd3, 0xee, 0xeb, 0x5a, 0xe3, 0x1b, 0xc8, 0xde, 0x65, 0x07, 0x80, 0xcc, 0xee,
	0x23, 0x5d, 0x4b, 0xb0, 0x67, 0x0e, 0x87, 0xd6, 0x4f, 0x69, 0xdf, 0x1e, 0x1e, 0x5d, 0xea, 0x72,
	0xe3, 0x7b, 0xd8, 0x7d, 0x8f, 0x1c, 0x00, 0xe2, 0x7a, 0x30, 0xc9, 0x51, 0xcb, 0xa0, 0x11, 0xfc,
	0x66, 0x82, 0x6d, 0x27, 0xb5, 0xd3, 0xea, 0xfc, 0x80, 0xbb, 0x8e, 0x2e, 0x77, 0x2e, 0xfe, 0xba,
	0x3d, 0x94, 0xfe, 0xbe, 0x3d, 0x94, 0xfe, 0xb9, 0x3d, 0x94, 0xfe, 0xf8, 0xf7, 0xf0, 0xc9, 0xcf,
	0x2f, 0x96, 0x5e, 0x72, 0x75, 0x33, 0x33, 0xdc, 0xf0, 0xba, 0x15, 0xc4, 0x2b, 0xd7, 0x6d, 0xce,
	0xd9, 0xba, 0x15, 0xb0, 0x70, 0x11, 0x37, 0xe9, 0xca, 0x6b, 0x2e, 0xc3, 0xd6, 0xce, 0x37, 0xe2,
	0x3b, 0xea, 0xfa, 0x7f, 0xca, 0xfa, 0x88, 0x85, 0xa7, 0xb6, 0x61, 0x8e, 0x07, 0xfc, 0x2a, 0x99,
	0xae, 0x3f, 0x2b, 0x88, 0x8f, 0xc1, 0xc9, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x66, 0x66, 0x9c,
	0x8f, 0x50, 0x06, 0x00, 0x00,
}

func (m *EACLRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EACLRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EACLRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Targets) > 0 {
		for iNdEx := len(m.Targets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Targets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Action != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x10
	}
	if m.Operation != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EACLRecord_Filter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EACLRecord_Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EACLRecord_Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.HeaderVal) > 0 {
		i -= len(m.HeaderVal)
		copy(dAtA[i:], m.HeaderVal)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HeaderVal)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.HeaderName) > 0 {
		i -= len(m.HeaderName)
		copy(dAtA[i:], m.HeaderName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HeaderName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MatchType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MatchType))
		i--
		dAtA[i] = 0x10
	}
	if m.HeaderType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.HeaderType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EACLRecord_Target) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EACLRecord_Target) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EACLRecord_Target) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.KeyList) > 0 {
		for iNdEx := len(m.KeyList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyList[iNdEx])
			copy(dAtA[i:], m.KeyList[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.KeyList[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Role != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EACLTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EACLTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EACLTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ContainerId != nil {
		{
			size, err := m.ContainerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BearerToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BearerToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BearerToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BearerToken_Body) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BearerToken_Body) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BearerToken_Body) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Lifetime != nil {
		{
			size, err := m.Lifetime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.OwnerId != nil {
		{
			size, err := m.OwnerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.EaclTable != nil {
		{
			size, err := m.EaclTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BearerToken_Body_TokenLifetime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BearerToken_Body_TokenLifetime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BearerToken_Body_TokenLifetime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Iat != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Iat))
		i--
		dAtA[i] = 0x18
	}
	if m.Nbf != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Nbf))
		i--
		dAtA[i] = 0x10
	}
	if m.Exp != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Exp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EACLRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != 0 {
		n += 1 + sovTypes(uint64(m.Operation))
	}
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EACLRecord_Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeaderType != 0 {
		n += 1 + sovTypes(uint64(m.HeaderType))
	}
	if m.MatchType != 0 {
		n += 1 + sovTypes(uint64(m.MatchType))
	}
	l = len(m.HeaderName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HeaderVal)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EACLRecord_Target) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Role != 0 {
		n += 1 + sovTypes(uint64(m.Role))
	}
	if len(m.KeyList) > 0 {
		for _, b := range m.KeyList {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EACLTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ContainerId != nil {
		l = m.ContainerId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BearerToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BearerToken_Body) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EaclTable != nil {
		l = m.EaclTable.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OwnerId != nil {
		l = m.OwnerId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Lifetime != nil {
		l = m.Lifetime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BearerToken_Body_TokenLifetime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exp != 0 {
		n += 1 + sovTypes(uint64(m.Exp))
	}
	if m.Nbf != 0 {
		n += 1 + sovTypes(uint64(m.Nbf))
	}
	if m.Iat != 0 {
		n += 1 + sovTypes(uint64(m.Iat))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EACLRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EACLRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EACLRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= Operation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= Action(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &EACLRecord_Filter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, &EACLRecord_Target{})
			if err := m.Targets[len(m.Targets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EACLRecord_Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderType", wireType)
			}
			m.HeaderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeaderType |= HeaderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchType", wireType)
			}
			m.MatchType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchType |= MatchType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderVal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderVal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EACLRecord_Target) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Target: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Target: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= Role(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyList = append(m.KeyList, make([]byte, postIndex-iNdEx))
			copy(m.KeyList[len(m.KeyList)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EACLTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EACLTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EACLTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &grpc.Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerId == nil {
				m.ContainerId = &grpc.ContainerID{}
			}
			if err := m.ContainerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &EACLRecord{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BearerToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BearerToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &BearerToken_Body{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &grpc.Signature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerToken_Body) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Body: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Body: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EaclTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EaclTable == nil {
				m.EaclTable = &EACLTable{}
			}
			if err := m.EaclTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerId == nil {
				m.OwnerId = &grpc.OwnerID{}
			}
			if err := m.OwnerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lifetime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lifetime == nil {
				m.Lifetime = &BearerToken_Body_TokenLifetime{}
			}
			if err := m.Lifetime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerToken_Body_TokenLifetime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenLifetime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenLifetime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nbf", wireType)
			}
			m.Nbf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nbf |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iat", wireType)
			}
			m.Iat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Iat |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
