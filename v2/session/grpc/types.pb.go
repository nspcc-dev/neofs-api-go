// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v2/session/grpc/types.proto

package session

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc1 "github.com/nspcc-dev/neofs-api-go/v2/acl/grpc"
	grpc "github.com/nspcc-dev/neofs-api-go/v2/refs/grpc"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Object request verbs
type ObjectSessionContext_Verb int32

const (
	// Unknown verb
	ObjectSessionContext_VERB_UNSPECIFIED ObjectSessionContext_Verb = 0
	// Refers to object.Put RPC call
	ObjectSessionContext_PUT ObjectSessionContext_Verb = 1
	// Refers to object.Get RPC call
	ObjectSessionContext_GET ObjectSessionContext_Verb = 2
	// Refers to object.Head RPC call
	ObjectSessionContext_HEAD ObjectSessionContext_Verb = 3
	// Refers to object.Search RPC call
	ObjectSessionContext_SEARCH ObjectSessionContext_Verb = 4
	// Refers to object.Delete RPC call
	ObjectSessionContext_DELETE ObjectSessionContext_Verb = 5
	// Refers to object.GetRange RPC call
	ObjectSessionContext_RANGE ObjectSessionContext_Verb = 6
	// Refers to object.GetRangeHash RPC call
	ObjectSessionContext_RANGEHASH ObjectSessionContext_Verb = 7
)

var ObjectSessionContext_Verb_name = map[int32]string{
	0: "VERB_UNSPECIFIED",
	1: "PUT",
	2: "GET",
	3: "HEAD",
	4: "SEARCH",
	5: "DELETE",
	6: "RANGE",
	7: "RANGEHASH",
}

var ObjectSessionContext_Verb_value = map[string]int32{
	"VERB_UNSPECIFIED": 0,
	"PUT":              1,
	"GET":              2,
	"HEAD":             3,
	"SEARCH":           4,
	"DELETE":           5,
	"RANGE":            6,
	"RANGEHASH":        7,
}

func (x ObjectSessionContext_Verb) String() string {
	return proto.EnumName(ObjectSessionContext_Verb_name, int32(x))
}

func (ObjectSessionContext_Verb) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6bbc551f310b2b05, []int{0, 0}
}

// Context information for Session Tokens related to ObjectService requests
type ObjectSessionContext struct {
	// Type of request for which the token is issued
	Verb ObjectSessionContext_Verb `protobuf:"varint,1,opt,name=verb,proto3,enum=neo.fs.v2.session.ObjectSessionContext_Verb" json:"verb,omitempty"`
	// Related Object address
	Address              *grpc.Address `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ObjectSessionContext) Reset()         { *m = ObjectSessionContext{} }
func (m *ObjectSessionContext) String() string { return proto.CompactTextString(m) }
func (*ObjectSessionContext) ProtoMessage()    {}
func (*ObjectSessionContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_6bbc551f310b2b05, []int{0}
}
func (m *ObjectSessionContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectSessionContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectSessionContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectSessionContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectSessionContext.Merge(m, src)
}
func (m *ObjectSessionContext) XXX_Size() int {
	return m.Size()
}
func (m *ObjectSessionContext) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectSessionContext.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectSessionContext proto.InternalMessageInfo

func (m *ObjectSessionContext) GetVerb() ObjectSessionContext_Verb {
	if m != nil {
		return m.Verb
	}
	return ObjectSessionContext_VERB_UNSPECIFIED
}

func (m *ObjectSessionContext) GetAddress() *grpc.Address {
	if m != nil {
		return m.Address
	}
	return nil
}

// NeoFS Session Token.
type SessionToken struct {
	// Session Token contains the proof of trust between peers to be attached in
	// requests for further verification. Please see corresponding section of
	// NeoFS Technical Specification for details.
	Body *SessionToken_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Signature of `SessionToken` information
	Signature            *grpc.Signature `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SessionToken) Reset()         { *m = SessionToken{} }
func (m *SessionToken) String() string { return proto.CompactTextString(m) }
func (*SessionToken) ProtoMessage()    {}
func (*SessionToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_6bbc551f310b2b05, []int{1}
}
func (m *SessionToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionToken.Merge(m, src)
}
func (m *SessionToken) XXX_Size() int {
	return m.Size()
}
func (m *SessionToken) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionToken.DiscardUnknown(m)
}

var xxx_messageInfo_SessionToken proto.InternalMessageInfo

func (m *SessionToken) GetBody() *SessionToken_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *SessionToken) GetSignature() *grpc.Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

// Session Token body
type SessionToken_Body struct {
	// Token identifier is a valid UUIDv4 in binary form
	Id []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Identifier of the session initiator
	OwnerId *grpc.OwnerID `protobuf:"bytes,2,opt,name=owner_id,json=ownerID,proto3" json:"owner_id,omitempty"`
	// Lifetime of the session
	Lifetime *SessionToken_Body_TokenLifetime `protobuf:"bytes,3,opt,name=lifetime,proto3" json:"lifetime,omitempty"`
	// Public key used in session
	SessionKey []byte `protobuf:"bytes,4,opt,name=session_key,json=sessionKey,proto3" json:"session_key,omitempty"`
	// Session Context information
	//
	// Types that are valid to be assigned to Context:
	//	*SessionToken_Body_Object
	Context              isSessionToken_Body_Context `protobuf_oneof:"context"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *SessionToken_Body) Reset()         { *m = SessionToken_Body{} }
func (m *SessionToken_Body) String() string { return proto.CompactTextString(m) }
func (*SessionToken_Body) ProtoMessage()    {}
func (*SessionToken_Body) Descriptor() ([]byte, []int) {
	return fileDescriptor_6bbc551f310b2b05, []int{1, 0}
}
func (m *SessionToken_Body) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionToken_Body) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionToken_Body.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionToken_Body) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionToken_Body.Merge(m, src)
}
func (m *SessionToken_Body) XXX_Size() int {
	return m.Size()
}
func (m *SessionToken_Body) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionToken_Body.DiscardUnknown(m)
}

var xxx_messageInfo_SessionToken_Body proto.InternalMessageInfo

type isSessionToken_Body_Context interface {
	isSessionToken_Body_Context()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SessionToken_Body_Object struct {
	Object *ObjectSessionContext `protobuf:"bytes,5,opt,name=object,proto3,oneof" json:"object,omitempty"`
}

func (*SessionToken_Body_Object) isSessionToken_Body_Context() {}

func (m *SessionToken_Body) GetContext() isSessionToken_Body_Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *SessionToken_Body) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SessionToken_Body) GetOwnerId() *grpc.OwnerID {
	if m != nil {
		return m.OwnerId
	}
	return nil
}

func (m *SessionToken_Body) GetLifetime() *SessionToken_Body_TokenLifetime {
	if m != nil {
		return m.Lifetime
	}
	return nil
}

func (m *SessionToken_Body) GetSessionKey() []byte {
	if m != nil {
		return m.SessionKey
	}
	return nil
}

func (m *SessionToken_Body) GetObject() *ObjectSessionContext {
	if x, ok := m.GetContext().(*SessionToken_Body_Object); ok {
		return x.Object
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SessionToken_Body) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SessionToken_Body_Object)(nil),
	}
}

// Lifetime parameters of the token. Filed names taken from rfc7519.
type SessionToken_Body_TokenLifetime struct {
	// Expiration Epoch
	Exp uint64 `protobuf:"varint,1,opt,name=exp,proto3" json:"exp,omitempty"`
	// Not valid before Epoch
	Nbf uint64 `protobuf:"varint,2,opt,name=nbf,proto3" json:"nbf,omitempty"`
	// Issued at Epoch
	Iat                  uint64   `protobuf:"varint,3,opt,name=iat,proto3" json:"iat,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SessionToken_Body_TokenLifetime) Reset()         { *m = SessionToken_Body_TokenLifetime{} }
func (m *SessionToken_Body_TokenLifetime) String() string { return proto.CompactTextString(m) }
func (*SessionToken_Body_TokenLifetime) ProtoMessage()    {}
func (*SessionToken_Body_TokenLifetime) Descriptor() ([]byte, []int) {
	return fileDescriptor_6bbc551f310b2b05, []int{1, 0, 0}
}
func (m *SessionToken_Body_TokenLifetime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionToken_Body_TokenLifetime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionToken_Body_TokenLifetime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionToken_Body_TokenLifetime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionToken_Body_TokenLifetime.Merge(m, src)
}
func (m *SessionToken_Body_TokenLifetime) XXX_Size() int {
	return m.Size()
}
func (m *SessionToken_Body_TokenLifetime) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionToken_Body_TokenLifetime.DiscardUnknown(m)
}

var xxx_messageInfo_SessionToken_Body_TokenLifetime proto.InternalMessageInfo

func (m *SessionToken_Body_TokenLifetime) GetExp() uint64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *SessionToken_Body_TokenLifetime) GetNbf() uint64 {
	if m != nil {
		return m.Nbf
	}
	return 0
}

func (m *SessionToken_Body_TokenLifetime) GetIat() uint64 {
	if m != nil {
		return m.Iat
	}
	return 0
}

// Extended headers for Request/Response.
type XHeader struct {
	// Key of the X-Header
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Value of the X-Header
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *XHeader) Reset()         { *m = XHeader{} }
func (m *XHeader) String() string { return proto.CompactTextString(m) }
func (*XHeader) ProtoMessage()    {}
func (*XHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_6bbc551f310b2b05, []int{2}
}
func (m *XHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XHeader.Merge(m, src)
}
func (m *XHeader) XXX_Size() int {
	return m.Size()
}
func (m *XHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_XHeader.DiscardUnknown(m)
}

var xxx_messageInfo_XHeader proto.InternalMessageInfo

func (m *XHeader) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *XHeader) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Meta information attached to the request. When forwarded between peers,
// request meta headers are folded in matryoshka style.
type RequestMetaHeader struct {
	// Peer's API version used
	Version *grpc.Version `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Peer's local epoch number. Set to 0 if unknown.
	Epoch uint64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// Maximum number of intermediate nodes in the request route
	Ttl uint32 `protobuf:"varint,3,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// Request X-Headers
	XHeaders []*XHeader `protobuf:"bytes,4,rep,name=x_headers,json=xHeaders,proto3" json:"x_headers,omitempty"`
	// Session token within which the request is sent
	SessionToken *SessionToken `protobuf:"bytes,5,opt,name=session_token,json=sessionToken,proto3" json:"session_token,omitempty"`
	// `BearerToken` with eACL overrides for the request
	BearerToken *grpc1.BearerToken `protobuf:"bytes,6,opt,name=bearer_token,json=bearerToken,proto3" json:"bearer_token,omitempty"`
	// `RequestMetaHeader` of the origin request
	Origin               *RequestMetaHeader `protobuf:"bytes,7,opt,name=origin,proto3" json:"origin,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *RequestMetaHeader) Reset()         { *m = RequestMetaHeader{} }
func (m *RequestMetaHeader) String() string { return proto.CompactTextString(m) }
func (*RequestMetaHeader) ProtoMessage()    {}
func (*RequestMetaHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_6bbc551f310b2b05, []int{3}
}
func (m *RequestMetaHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestMetaHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestMetaHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestMetaHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestMetaHeader.Merge(m, src)
}
func (m *RequestMetaHeader) XXX_Size() int {
	return m.Size()
}
func (m *RequestMetaHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestMetaHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RequestMetaHeader proto.InternalMessageInfo

func (m *RequestMetaHeader) GetVersion() *grpc.Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *RequestMetaHeader) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *RequestMetaHeader) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *RequestMetaHeader) GetXHeaders() []*XHeader {
	if m != nil {
		return m.XHeaders
	}
	return nil
}

func (m *RequestMetaHeader) GetSessionToken() *SessionToken {
	if m != nil {
		return m.SessionToken
	}
	return nil
}

func (m *RequestMetaHeader) GetBearerToken() *grpc1.BearerToken {
	if m != nil {
		return m.BearerToken
	}
	return nil
}

func (m *RequestMetaHeader) GetOrigin() *RequestMetaHeader {
	if m != nil {
		return m.Origin
	}
	return nil
}

// Information about the response
type ResponseMetaHeader struct {
	// Peer's API version used
	Version *grpc.Version `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Peer's local epoch number
	Epoch uint64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// Maximum number of intermediate nodes in the request route
	Ttl uint32 `protobuf:"varint,3,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// Response X-Headers
	XHeaders []*XHeader `protobuf:"bytes,4,rep,name=x_headers,json=xHeaders,proto3" json:"x_headers,omitempty"`
	// `ResponseMetaHeader` of the origin request
	Origin               *ResponseMetaHeader `protobuf:"bytes,5,opt,name=origin,proto3" json:"origin,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ResponseMetaHeader) Reset()         { *m = ResponseMetaHeader{} }
func (m *ResponseMetaHeader) String() string { return proto.CompactTextString(m) }
func (*ResponseMetaHeader) ProtoMessage()    {}
func (*ResponseMetaHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_6bbc551f310b2b05, []int{4}
}
func (m *ResponseMetaHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseMetaHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseMetaHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseMetaHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseMetaHeader.Merge(m, src)
}
func (m *ResponseMetaHeader) XXX_Size() int {
	return m.Size()
}
func (m *ResponseMetaHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseMetaHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseMetaHeader proto.InternalMessageInfo

func (m *ResponseMetaHeader) GetVersion() *grpc.Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *ResponseMetaHeader) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *ResponseMetaHeader) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *ResponseMetaHeader) GetXHeaders() []*XHeader {
	if m != nil {
		return m.XHeaders
	}
	return nil
}

func (m *ResponseMetaHeader) GetOrigin() *ResponseMetaHeader {
	if m != nil {
		return m.Origin
	}
	return nil
}

// Verification info for request signed by all intermediate nodes.
type RequestVerificationHeader struct {
	// Request Body signature. Should be generated once by request initiator.
	BodySignature *grpc.Signature `protobuf:"bytes,1,opt,name=body_signature,json=bodySignature,proto3" json:"body_signature,omitempty"`
	// Request Meta signature is added and signed by each intermediate node
	MetaSignature *grpc.Signature `protobuf:"bytes,2,opt,name=meta_signature,json=metaSignature,proto3" json:"meta_signature,omitempty"`
	// Signature of previous hops
	OriginSignature *grpc.Signature `protobuf:"bytes,3,opt,name=origin_signature,json=originSignature,proto3" json:"origin_signature,omitempty"`
	// Chain of previous hops signatures
	Origin               *RequestVerificationHeader `protobuf:"bytes,4,opt,name=origin,proto3" json:"origin,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *RequestVerificationHeader) Reset()         { *m = RequestVerificationHeader{} }
func (m *RequestVerificationHeader) String() string { return proto.CompactTextString(m) }
func (*RequestVerificationHeader) ProtoMessage()    {}
func (*RequestVerificationHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_6bbc551f310b2b05, []int{5}
}
func (m *RequestVerificationHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestVerificationHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestVerificationHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestVerificationHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestVerificationHeader.Merge(m, src)
}
func (m *RequestVerificationHeader) XXX_Size() int {
	return m.Size()
}
func (m *RequestVerificationHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestVerificationHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RequestVerificationHeader proto.InternalMessageInfo

func (m *RequestVerificationHeader) GetBodySignature() *grpc.Signature {
	if m != nil {
		return m.BodySignature
	}
	return nil
}

func (m *RequestVerificationHeader) GetMetaSignature() *grpc.Signature {
	if m != nil {
		return m.MetaSignature
	}
	return nil
}

func (m *RequestVerificationHeader) GetOriginSignature() *grpc.Signature {
	if m != nil {
		return m.OriginSignature
	}
	return nil
}

func (m *RequestVerificationHeader) GetOrigin() *RequestVerificationHeader {
	if m != nil {
		return m.Origin
	}
	return nil
}

// Verification info for response signed by all intermediate nodes
type ResponseVerificationHeader struct {
	// Response Body signature. Should be generated once by answering node.
	BodySignature *grpc.Signature `protobuf:"bytes,1,opt,name=body_signature,json=bodySignature,proto3" json:"body_signature,omitempty"`
	// Response Meta signature is added and signed by each intermediate node
	MetaSignature *grpc.Signature `protobuf:"bytes,2,opt,name=meta_signature,json=metaSignature,proto3" json:"meta_signature,omitempty"`
	// Signature of previous hops
	OriginSignature *grpc.Signature `protobuf:"bytes,3,opt,name=origin_signature,json=originSignature,proto3" json:"origin_signature,omitempty"`
	// Chain of previous hops signatures
	Origin               *ResponseVerificationHeader `protobuf:"bytes,4,opt,name=origin,proto3" json:"origin,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *ResponseVerificationHeader) Reset()         { *m = ResponseVerificationHeader{} }
func (m *ResponseVerificationHeader) String() string { return proto.CompactTextString(m) }
func (*ResponseVerificationHeader) ProtoMessage()    {}
func (*ResponseVerificationHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_6bbc551f310b2b05, []int{6}
}
func (m *ResponseVerificationHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseVerificationHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseVerificationHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseVerificationHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseVerificationHeader.Merge(m, src)
}
func (m *ResponseVerificationHeader) XXX_Size() int {
	return m.Size()
}
func (m *ResponseVerificationHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseVerificationHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseVerificationHeader proto.InternalMessageInfo

func (m *ResponseVerificationHeader) GetBodySignature() *grpc.Signature {
	if m != nil {
		return m.BodySignature
	}
	return nil
}

func (m *ResponseVerificationHeader) GetMetaSignature() *grpc.Signature {
	if m != nil {
		return m.MetaSignature
	}
	return nil
}

func (m *ResponseVerificationHeader) GetOriginSignature() *grpc.Signature {
	if m != nil {
		return m.OriginSignature
	}
	return nil
}

func (m *ResponseVerificationHeader) GetOrigin() *ResponseVerificationHeader {
	if m != nil {
		return m.Origin
	}
	return nil
}

func init() {
	proto.RegisterEnum("neo.fs.v2.session.ObjectSessionContext_Verb", ObjectSessionContext_Verb_name, ObjectSessionContext_Verb_value)
	proto.RegisterType((*ObjectSessionContext)(nil), "neo.fs.v2.session.ObjectSessionContext")
	proto.RegisterType((*SessionToken)(nil), "neo.fs.v2.session.SessionToken")
	proto.RegisterType((*SessionToken_Body)(nil), "neo.fs.v2.session.SessionToken.Body")
	proto.RegisterType((*SessionToken_Body_TokenLifetime)(nil), "neo.fs.v2.session.SessionToken.Body.TokenLifetime")
	proto.RegisterType((*XHeader)(nil), "neo.fs.v2.session.XHeader")
	proto.RegisterType((*RequestMetaHeader)(nil), "neo.fs.v2.session.RequestMetaHeader")
	proto.RegisterType((*ResponseMetaHeader)(nil), "neo.fs.v2.session.ResponseMetaHeader")
	proto.RegisterType((*RequestVerificationHeader)(nil), "neo.fs.v2.session.RequestVerificationHeader")
	proto.RegisterType((*ResponseVerificationHeader)(nil), "neo.fs.v2.session.ResponseVerificationHeader")
}

func init() { proto.RegisterFile("v2/session/grpc/types.proto", fileDescriptor_6bbc551f310b2b05) }

var fileDescriptor_6bbc551f310b2b05 = []byte{
	// 839 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x56, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xce, 0xae, 0x37, 0x76, 0x7c, 0x1c, 0x87, 0xed, 0x28, 0x52, 0x5d, 0x23, 0xa5, 0x91, 0x05,
	0x22, 0x17, 0xcd, 0x5a, 0x59, 0x2e, 0x00, 0x41, 0xa5, 0xda, 0xf1, 0xb6, 0x8e, 0x28, 0x69, 0x34,
	0x4e, 0x23, 0xc4, 0x8d, 0xb5, 0x3f, 0xc7, 0xce, 0xb6, 0xce, 0xce, 0xb2, 0x33, 0x59, 0xe2, 0x37,
	0xe1, 0x19, 0x40, 0xbc, 0x07, 0x97, 0xbd, 0xe0, 0x01, 0x50, 0xb8, 0x40, 0xe2, 0x05, 0xb8, 0x45,
	0x33, 0x3b, 0x76, 0x4c, 0x9c, 0x90, 0x70, 0x87, 0xb8, 0x3b, 0xb3, 0x73, 0xbe, 0x6f, 0xbe, 0xef,
	0x9b, 0xe3, 0x91, 0xe1, 0xfd, 0xdc, 0x6d, 0x73, 0xe4, 0x3c, 0x66, 0x49, 0x7b, 0x9c, 0xa5, 0x61,
	0x5b, 0x4c, 0x53, 0xe4, 0x4e, 0x9a, 0x31, 0xc1, 0xc8, 0x83, 0x04, 0x99, 0x33, 0xe2, 0x4e, 0xee,
	0x3a, 0xba, 0xa7, 0xd9, 0xc8, 0xdd, 0x76, 0x86, 0x23, 0xbe, 0xd4, 0xdc, 0x7c, 0x98, 0xbb, 0x6d,
	0x3f, 0x9c, 0x2c, 0x6d, 0xb4, 0xfe, 0x34, 0x60, 0xf3, 0x55, 0xf0, 0x06, 0x43, 0x31, 0x28, 0x48,
	0xf6, 0x59, 0x22, 0xf0, 0x42, 0x90, 0x67, 0x60, 0xe5, 0x98, 0x05, 0x0d, 0x63, 0xdb, 0xd8, 0xd9,
	0x70, 0x9f, 0x38, 0x4b, 0xa7, 0x39, 0x37, 0xc1, 0x9c, 0x13, 0xcc, 0x02, 0xaa, 0x90, 0x64, 0x0f,
	0x2a, 0x7e, 0x14, 0x65, 0xc8, 0x79, 0xc3, 0xdc, 0x36, 0x76, 0x6a, 0xee, 0xc3, 0x05, 0x12, 0x29,
	0xd3, 0xe9, 0x14, 0xdb, 0x74, 0xd6, 0xd7, 0x7a, 0x03, 0x96, 0x24, 0x20, 0x9b, 0x60, 0x9f, 0x78,
	0xb4, 0x3b, 0x7c, 0x7d, 0x38, 0x38, 0xf2, 0xf6, 0x0f, 0x9e, 0x1f, 0x78, 0x3d, 0x7b, 0x85, 0x54,
	0xa0, 0x74, 0xf4, 0xfa, 0xd8, 0x36, 0x64, 0xf1, 0xc2, 0x3b, 0xb6, 0x4d, 0xb2, 0x06, 0x56, 0xdf,
	0xeb, 0xf4, 0xec, 0x12, 0x01, 0x28, 0x0f, 0xbc, 0x0e, 0xdd, 0xef, 0xdb, 0x96, 0xac, 0x7b, 0xde,
	0x4b, 0xef, 0xd8, 0xb3, 0x57, 0x49, 0x15, 0x56, 0x69, 0xe7, 0xf0, 0x85, 0x67, 0x97, 0x49, 0x1d,
	0xaa, 0xaa, 0xec, 0x77, 0x06, 0x7d, 0xbb, 0xd2, 0xfa, 0xa5, 0x04, 0xeb, 0x5a, 0xfc, 0x31, 0x7b,
	0x8b, 0x09, 0xf9, 0x14, 0xac, 0x80, 0x45, 0x53, 0xe5, 0xb8, 0xe6, 0x7e, 0x70, 0x83, 0xe3, 0xc5,
	0x76, 0xa7, 0xcb, 0xa2, 0x29, 0x55, 0x08, 0xf2, 0x09, 0x54, 0x79, 0x3c, 0x4e, 0x7c, 0x71, 0x9e,
	0xa1, 0xf6, 0xfa, 0xe8, 0xba, 0xd7, 0xc1, 0xac, 0x81, 0x5e, 0xf5, 0x36, 0xdf, 0x99, 0x60, 0x49,
	0x1e, 0xb2, 0x01, 0x66, 0x1c, 0xa9, 0x93, 0xd7, 0xa9, 0x19, 0x47, 0xc4, 0x85, 0x35, 0xf6, 0x5d,
	0x82, 0xd9, 0x30, 0x8e, 0x6e, 0x0b, 0xef, 0x95, 0xdc, 0x3f, 0xe8, 0xd1, 0x0a, 0x2b, 0x0a, 0x72,
	0x08, 0x6b, 0x93, 0x78, 0x84, 0x22, 0x3e, 0xc3, 0x46, 0x49, 0x61, 0xdc, 0xfb, 0x78, 0x70, 0x54,
	0xf9, 0x52, 0x23, 0xe9, 0x9c, 0x83, 0x3c, 0x86, 0x9a, 0x06, 0x0d, 0xdf, 0xe2, 0xb4, 0x61, 0x29,
	0x71, 0xa0, 0x3f, 0x7d, 0x89, 0x53, 0xd2, 0x81, 0x32, 0x53, 0x33, 0xd0, 0x58, 0x55, 0xc7, 0x7d,
	0x74, 0xcf, 0x21, 0xe9, 0xaf, 0x50, 0x0d, 0x6c, 0x7a, 0x50, 0xff, 0xdb, 0xf1, 0xc4, 0x86, 0x12,
	0x5e, 0xa4, 0x2a, 0x09, 0x8b, 0xca, 0x52, 0x7e, 0x49, 0x82, 0x91, 0x4a, 0xc1, 0xa2, 0xb2, 0x94,
	0x5f, 0x62, 0x5f, 0x28, 0x8f, 0x16, 0x95, 0x65, 0xb7, 0x0a, 0x95, 0xb0, 0xe0, 0x6e, 0xed, 0x41,
	0xe5, 0xeb, 0x3e, 0xfa, 0x11, 0x66, 0xb2, 0x4f, 0x0a, 0x97, 0x5c, 0x55, 0x2a, 0x4b, 0xb2, 0x09,
	0xab, 0xb9, 0x3f, 0x39, 0x2f, 0x2e, 0xa9, 0x4a, 0x8b, 0x45, 0xeb, 0x0f, 0x13, 0x1e, 0x50, 0xfc,
	0xf6, 0x1c, 0xb9, 0xf8, 0x0a, 0x85, 0xaf, 0xd1, 0x7b, 0x50, 0xc9, 0x31, 0x93, 0xb2, 0xf5, 0x44,
	0x2c, 0xdd, 0xc0, 0x49, 0xb1, 0x4d, 0x67, 0x7d, 0x92, 0x1e, 0x53, 0x16, 0x9e, 0x6a, 0xb1, 0xc5,
	0x42, 0xca, 0x10, 0x62, 0xa2, 0xe4, 0xd6, 0xa9, 0x2c, 0xe5, 0xbc, 0x5c, 0x0c, 0x4f, 0xd5, 0x31,
	0xbc, 0x61, 0x6d, 0x97, 0x76, 0x6a, 0x6e, 0xf3, 0x86, 0xec, 0xb4, 0x0f, 0xba, 0x76, 0x51, 0x14,
	0x9c, 0xf4, 0xa0, 0x3e, 0xbb, 0x12, 0x21, 0x63, 0xd3, 0xc1, 0x3f, 0xbe, 0xe3, 0x9e, 0xe9, 0x3a,
	0x5f, 0x1c, 0xf4, 0xa7, 0xb0, 0x1e, 0xa0, 0x9f, 0x61, 0xa6, 0x49, 0xca, 0x8a, 0x64, 0x51, 0x81,
	0x1f, 0x4e, 0x9c, 0xae, 0x6a, 0x29, 0xf0, 0xb5, 0xe0, 0x6a, 0x41, 0xbe, 0x80, 0x32, 0xcb, 0xe2,
	0x71, 0x9c, 0x34, 0x2a, 0xb7, 0xfe, 0x52, 0x96, 0xe2, 0xa4, 0x1a, 0xd3, 0xfa, 0xdd, 0x00, 0x42,
	0x91, 0xa7, 0x2c, 0xe1, 0xf8, 0x1f, 0x4f, 0xfb, 0xe9, 0xdc, 0x68, 0x11, 0xf3, 0x87, 0x37, 0x1a,
	0xbd, 0x6e, 0x65, 0xee, 0xf4, 0x47, 0x13, 0x1e, 0xe9, 0x1c, 0x4e, 0x30, 0x8b, 0x47, 0x71, 0xe8,
	0x8b, 0x98, 0x25, 0xda, 0xf0, 0x33, 0xd8, 0x90, 0x6f, 0xc7, 0xf0, 0xea, 0xe1, 0x30, 0xee, 0x7a,
	0x38, 0xea, 0x12, 0x30, 0x5f, 0x4a, 0x86, 0x33, 0x14, 0xfe, 0xf0, 0x5f, 0x3c, 0x3d, 0x75, 0x09,
	0xb8, 0x62, 0xe8, 0x81, 0x5d, 0x68, 0x5d, 0xe0, 0x28, 0xdd, 0xc5, 0xf1, 0x5e, 0x01, 0x59, 0x64,
	0x99, 0xc5, 0x64, 0x29, 0xec, 0x93, 0xdb, 0xe7, 0x61, 0x39, 0x87, 0x79, 0x5a, 0x3f, 0x99, 0xd0,
	0x9c, 0x85, 0xf9, 0xbf, 0x8e, 0xcb, 0xbb, 0x16, 0xd7, 0xee, 0x3f, 0x4c, 0xd5, 0xed, 0x79, 0x75,
	0x83, 0x9f, 0x2f, 0xb7, 0x8c, 0x77, 0x97, 0x5b, 0xc6, 0xaf, 0x97, 0x5b, 0xc6, 0xf7, 0xbf, 0x6d,
	0xad, 0x7c, 0xf3, 0xd9, 0x38, 0x16, 0xa7, 0xe7, 0x81, 0x13, 0xb2, 0xb3, 0x76, 0xc2, 0xd3, 0x30,
	0xdc, 0x8d, 0x30, 0x6f, 0x27, 0xc8, 0x46, 0x7c, 0xd7, 0x4f, 0xe3, 0xdd, 0x31, 0x6b, 0x5f, 0xfb,
	0x3f, 0xf1, 0xb9, 0x5e, 0xfc, 0x60, 0x6e, 0x1e, 0x22, 0x7b, 0x3e, 0x70, 0x3a, 0x47, 0x07, 0x52,
	0x86, 0x7e, 0x3b, 0x82, 0xb2, 0xfa, 0x8f, 0xf0, 0xf1, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x18,
	0x2f, 0x25, 0xb1, 0x88, 0x08, 0x00, 0x00,
}

func (m *ObjectSessionContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectSessionContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectSessionContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Verb != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Verb))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionToken_Body) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionToken_Body) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionToken_Body) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Context != nil {
		{
			size := m.Context.Size()
			i -= size
			if _, err := m.Context.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.SessionKey) > 0 {
		i -= len(m.SessionKey)
		copy(dAtA[i:], m.SessionKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SessionKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.Lifetime != nil {
		{
			size, err := m.Lifetime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.OwnerId != nil {
		{
			size, err := m.OwnerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionToken_Body_Object) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionToken_Body_Object) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Object != nil {
		{
			size, err := m.Object.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *SessionToken_Body_TokenLifetime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionToken_Body_TokenLifetime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionToken_Body_TokenLifetime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Iat != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Iat))
		i--
		dAtA[i] = 0x18
	}
	if m.Nbf != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Nbf))
		i--
		dAtA[i] = 0x10
	}
	if m.Exp != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Exp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *XHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *XHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestMetaHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestMetaHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestMetaHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Origin != nil {
		{
			size, err := m.Origin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.BearerToken != nil {
		{
			size, err := m.BearerToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.SessionToken != nil {
		{
			size, err := m.SessionToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.XHeaders) > 0 {
		for iNdEx := len(m.XHeaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.XHeaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Ttl != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Ttl))
		i--
		dAtA[i] = 0x18
	}
	if m.Epoch != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseMetaHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseMetaHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseMetaHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Origin != nil {
		{
			size, err := m.Origin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.XHeaders) > 0 {
		for iNdEx := len(m.XHeaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.XHeaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Ttl != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Ttl))
		i--
		dAtA[i] = 0x18
	}
	if m.Epoch != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestVerificationHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestVerificationHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestVerificationHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Origin != nil {
		{
			size, err := m.Origin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OriginSignature != nil {
		{
			size, err := m.OriginSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MetaSignature != nil {
		{
			size, err := m.MetaSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BodySignature != nil {
		{
			size, err := m.BodySignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseVerificationHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseVerificationHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseVerificationHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Origin != nil {
		{
			size, err := m.Origin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OriginSignature != nil {
		{
			size, err := m.OriginSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MetaSignature != nil {
		{
			size, err := m.MetaSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BodySignature != nil {
		{
			size, err := m.BodySignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ObjectSessionContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Verb != 0 {
		n += 1 + sovTypes(uint64(m.Verb))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionToken_Body) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OwnerId != nil {
		l = m.OwnerId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Lifetime != nil {
		l = m.Lifetime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SessionKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Context != nil {
		n += m.Context.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionToken_Body_Object) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SessionToken_Body_TokenLifetime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exp != 0 {
		n += 1 + sovTypes(uint64(m.Exp))
	}
	if m.Nbf != 0 {
		n += 1 + sovTypes(uint64(m.Nbf))
	}
	if m.Iat != 0 {
		n += 1 + sovTypes(uint64(m.Iat))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *XHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestMetaHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovTypes(uint64(m.Epoch))
	}
	if m.Ttl != 0 {
		n += 1 + sovTypes(uint64(m.Ttl))
	}
	if len(m.XHeaders) > 0 {
		for _, e := range m.XHeaders {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.SessionToken != nil {
		l = m.SessionToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BearerToken != nil {
		l = m.BearerToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Origin != nil {
		l = m.Origin.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseMetaHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovTypes(uint64(m.Epoch))
	}
	if m.Ttl != 0 {
		n += 1 + sovTypes(uint64(m.Ttl))
	}
	if len(m.XHeaders) > 0 {
		for _, e := range m.XHeaders {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Origin != nil {
		l = m.Origin.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestVerificationHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BodySignature != nil {
		l = m.BodySignature.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MetaSignature != nil {
		l = m.MetaSignature.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OriginSignature != nil {
		l = m.OriginSignature.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Origin != nil {
		l = m.Origin.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseVerificationHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BodySignature != nil {
		l = m.BodySignature.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MetaSignature != nil {
		l = m.MetaSignature.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OriginSignature != nil {
		l = m.OriginSignature.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Origin != nil {
		l = m.Origin.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ObjectSessionContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectSessionContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectSessionContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verb", wireType)
			}
			m.Verb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Verb |= ObjectSessionContext_Verb(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &grpc.Address{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &SessionToken_Body{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &grpc.Signature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionToken_Body) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Body: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Body: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerId == nil {
				m.OwnerId = &grpc.OwnerID{}
			}
			if err := m.OwnerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lifetime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lifetime == nil {
				m.Lifetime = &SessionToken_Body_TokenLifetime{}
			}
			if err := m.Lifetime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionKey = append(m.SessionKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SessionKey == nil {
				m.SessionKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ObjectSessionContext{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Context = &SessionToken_Body_Object{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionToken_Body_TokenLifetime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenLifetime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenLifetime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nbf", wireType)
			}
			m.Nbf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nbf |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iat", wireType)
			}
			m.Iat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Iat |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestMetaHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestMetaHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestMetaHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &grpc.Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XHeaders = append(m.XHeaders, &XHeader{})
			if err := m.XHeaders[len(m.XHeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SessionToken == nil {
				m.SessionToken = &SessionToken{}
			}
			if err := m.SessionToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BearerToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BearerToken == nil {
				m.BearerToken = &grpc1.BearerToken{}
			}
			if err := m.BearerToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Origin == nil {
				m.Origin = &RequestMetaHeader{}
			}
			if err := m.Origin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseMetaHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseMetaHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseMetaHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &grpc.Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XHeaders = append(m.XHeaders, &XHeader{})
			if err := m.XHeaders[len(m.XHeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Origin == nil {
				m.Origin = &ResponseMetaHeader{}
			}
			if err := m.Origin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestVerificationHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestVerificationHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestVerificationHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodySignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BodySignature == nil {
				m.BodySignature = &grpc.Signature{}
			}
			if err := m.BodySignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetaSignature == nil {
				m.MetaSignature = &grpc.Signature{}
			}
			if err := m.MetaSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginSignature == nil {
				m.OriginSignature = &grpc.Signature{}
			}
			if err := m.OriginSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Origin == nil {
				m.Origin = &RequestVerificationHeader{}
			}
			if err := m.Origin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseVerificationHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseVerificationHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseVerificationHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodySignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BodySignature == nil {
				m.BodySignature = &grpc.Signature{}
			}
			if err := m.BodySignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetaSignature == nil {
				m.MetaSignature = &grpc.Signature{}
			}
			if err := m.MetaSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginSignature == nil {
				m.OriginSignature = &grpc.Signature{}
			}
			if err := m.OriginSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Origin == nil {
				m.Origin = &ResponseVerificationHeader{}
			}
			if err := m.Origin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
