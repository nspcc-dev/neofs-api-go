// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: accounting/types.proto

package accounting

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	decimal "github.com/nspcc-dev/neofs-proto/decimal"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Unit can be Unlimited, based on NeoFS epoch or Neo block
type Lifetime_Unit int32

const (
	Lifetime_Unlimited  Lifetime_Unit = 0
	Lifetime_NeoFSEpoch Lifetime_Unit = 1
	Lifetime_NeoBlock   Lifetime_Unit = 2
)

var Lifetime_Unit_name = map[int32]string{
	0: "Unlimited",
	1: "NeoFSEpoch",
	2: "NeoBlock",
}

var Lifetime_Unit_value = map[string]int32{
	"Unlimited":  0,
	"NeoFSEpoch": 1,
	"NeoBlock":   2,
}

func (x Lifetime_Unit) String() string {
	return proto.EnumName(Lifetime_Unit_name, int32(x))
}

func (Lifetime_Unit) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_437c556d7375b726, []int{4, 0}
}

// Type can be withdrawal, payIO or inner
type Tx_Type int32

const (
	Tx_Unknown  Tx_Type = 0
	Tx_Withdraw Tx_Type = 1
	Tx_PayIO    Tx_Type = 2
	Tx_Inner    Tx_Type = 3
)

var Tx_Type_name = map[int32]string{
	0: "Unknown",
	1: "Withdraw",
	2: "PayIO",
	3: "Inner",
}

var Tx_Type_value = map[string]int32{
	"Unknown":  0,
	"Withdraw": 1,
	"PayIO":    2,
	"Inner":    3,
}

func (x Tx_Type) String() string {
	return proto.EnumName(Tx_Type_name, int32(x))
}

func (Tx_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_437c556d7375b726, []int{5, 0}
}

type Account struct {
	// OwnerID is a wallet address
	OwnerID OwnerID `protobuf:"bytes,1,opt,name=OwnerID,proto3,customtype=OwnerID" json:"OwnerID"`
	// Address is identifier of accounting record
	Address string `protobuf:"bytes,2,opt,name=Address,proto3" json:"Address,omitempty"`
	// ParentAddress is identifier of parent accounting record
	ParentAddress string `protobuf:"bytes,3,opt,name=ParentAddress,proto3" json:"ParentAddress,omitempty"`
	// ActiveFunds is amount of active (non locked) funds for account
	ActiveFunds *decimal.Decimal `protobuf:"bytes,4,opt,name=ActiveFunds,proto3" json:"ActiveFunds,omitempty"`
	// Lifetime is time until account is valid (used for lock accounts)
	Lifetime Lifetime `protobuf:"bytes,5,opt,name=Lifetime,proto3" json:"Lifetime"`
	// LockTarget is the purpose of lock funds (it might be withdraw or payment for storage)
	LockTarget *LockTarget `protobuf:"bytes,6,opt,name=LockTarget,proto3" json:"LockTarget,omitempty"`
	// LockAccounts contains child accounts with locked funds
	LockAccounts         []*Account `protobuf:"bytes,7,rep,name=LockAccounts,proto3" json:"LockAccounts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Account) Reset()         { *m = Account{} }
func (m *Account) String() string { return proto.CompactTextString(m) }
func (*Account) ProtoMessage()    {}
func (*Account) Descriptor() ([]byte, []int) {
	return fileDescriptor_437c556d7375b726, []int{0}
}
func (m *Account) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Account) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account.Merge(m, src)
}
func (m *Account) XXX_Size() int {
	return m.Size()
}
func (m *Account) XXX_DiscardUnknown() {
	xxx_messageInfo_Account.DiscardUnknown(m)
}

var xxx_messageInfo_Account proto.InternalMessageInfo

func (m *Account) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Account) GetParentAddress() string {
	if m != nil {
		return m.ParentAddress
	}
	return ""
}

func (m *Account) GetActiveFunds() *decimal.Decimal {
	if m != nil {
		return m.ActiveFunds
	}
	return nil
}

func (m *Account) GetLifetime() Lifetime {
	if m != nil {
		return m.Lifetime
	}
	return Lifetime{}
}

func (m *Account) GetLockTarget() *LockTarget {
	if m != nil {
		return m.LockTarget
	}
	return nil
}

func (m *Account) GetLockAccounts() []*Account {
	if m != nil {
		return m.LockAccounts
	}
	return nil
}

// LockTarget must be one of two options
type LockTarget struct {
	// Types that are valid to be assigned to Target:
	//	*LockTarget_WithdrawTarget
	//	*LockTarget_ContainerCreateTarget
	Target               isLockTarget_Target `protobuf_oneof:"Target"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *LockTarget) Reset()         { *m = LockTarget{} }
func (m *LockTarget) String() string { return proto.CompactTextString(m) }
func (*LockTarget) ProtoMessage()    {}
func (*LockTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_437c556d7375b726, []int{1}
}
func (m *LockTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LockTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockTarget.Merge(m, src)
}
func (m *LockTarget) XXX_Size() int {
	return m.Size()
}
func (m *LockTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_LockTarget.DiscardUnknown(m)
}

var xxx_messageInfo_LockTarget proto.InternalMessageInfo

type isLockTarget_Target interface {
	isLockTarget_Target()
	MarshalTo([]byte) (int, error)
	Size() int
}

type LockTarget_WithdrawTarget struct {
	WithdrawTarget *WithdrawTarget `protobuf:"bytes,1,opt,name=WithdrawTarget,proto3,oneof" json:"WithdrawTarget,omitempty"`
}
type LockTarget_ContainerCreateTarget struct {
	ContainerCreateTarget *ContainerCreateTarget `protobuf:"bytes,2,opt,name=ContainerCreateTarget,proto3,oneof" json:"ContainerCreateTarget,omitempty"`
}

func (*LockTarget_WithdrawTarget) isLockTarget_Target()        {}
func (*LockTarget_ContainerCreateTarget) isLockTarget_Target() {}

func (m *LockTarget) GetTarget() isLockTarget_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *LockTarget) GetWithdrawTarget() *WithdrawTarget {
	if x, ok := m.GetTarget().(*LockTarget_WithdrawTarget); ok {
		return x.WithdrawTarget
	}
	return nil
}

func (m *LockTarget) GetContainerCreateTarget() *ContainerCreateTarget {
	if x, ok := m.GetTarget().(*LockTarget_ContainerCreateTarget); ok {
		return x.ContainerCreateTarget
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LockTarget) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LockTarget_WithdrawTarget)(nil),
		(*LockTarget_ContainerCreateTarget)(nil),
	}
}

type Balances struct {
	// Accounts contains multiple account snapshots
	Accounts             []Account `protobuf:"bytes,1,rep,name=Accounts,proto3" json:"Accounts"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Balances) Reset()         { *m = Balances{} }
func (m *Balances) String() string { return proto.CompactTextString(m) }
func (*Balances) ProtoMessage()    {}
func (*Balances) Descriptor() ([]byte, []int) {
	return fileDescriptor_437c556d7375b726, []int{2}
}
func (m *Balances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Balances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Balances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Balances.Merge(m, src)
}
func (m *Balances) XXX_Size() int {
	return m.Size()
}
func (m *Balances) XXX_DiscardUnknown() {
	xxx_messageInfo_Balances.DiscardUnknown(m)
}

var xxx_messageInfo_Balances proto.InternalMessageInfo

func (m *Balances) GetAccounts() []Account {
	if m != nil {
		return m.Accounts
	}
	return nil
}

type PayIO struct {
	// BlockID contains id of the NEO block where withdraw or deposit
	// call was invoked
	BlockID uint64 `protobuf:"varint,1,opt,name=BlockID,proto3" json:"BlockID,omitempty"`
	// Transactions contains all transactions that founded in block
	// and used for PayIO
	Transactions         []Tx     `protobuf:"bytes,2,rep,name=Transactions,proto3" json:"Transactions"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PayIO) Reset()         { *m = PayIO{} }
func (m *PayIO) String() string { return proto.CompactTextString(m) }
func (*PayIO) ProtoMessage()    {}
func (*PayIO) Descriptor() ([]byte, []int) {
	return fileDescriptor_437c556d7375b726, []int{3}
}
func (m *PayIO) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayIO) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PayIO) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayIO.Merge(m, src)
}
func (m *PayIO) XXX_Size() int {
	return m.Size()
}
func (m *PayIO) XXX_DiscardUnknown() {
	xxx_messageInfo_PayIO.DiscardUnknown(m)
}

var xxx_messageInfo_PayIO proto.InternalMessageInfo

func (m *PayIO) GetBlockID() uint64 {
	if m != nil {
		return m.BlockID
	}
	return 0
}

func (m *PayIO) GetTransactions() []Tx {
	if m != nil {
		return m.Transactions
	}
	return nil
}

type Lifetime struct {
	// Unit describes how lifetime is measured in account
	Unit Lifetime_Unit `protobuf:"varint,1,opt,name=unit,proto3,enum=accounting.Lifetime_Unit" json:"unit,omitempty"`
	// Value describes how long lifetime will be valid
	Value                int64    `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Lifetime) Reset()         { *m = Lifetime{} }
func (m *Lifetime) String() string { return proto.CompactTextString(m) }
func (*Lifetime) ProtoMessage()    {}
func (*Lifetime) Descriptor() ([]byte, []int) {
	return fileDescriptor_437c556d7375b726, []int{4}
}
func (m *Lifetime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Lifetime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Lifetime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lifetime.Merge(m, src)
}
func (m *Lifetime) XXX_Size() int {
	return m.Size()
}
func (m *Lifetime) XXX_DiscardUnknown() {
	xxx_messageInfo_Lifetime.DiscardUnknown(m)
}

var xxx_messageInfo_Lifetime proto.InternalMessageInfo

func (m *Lifetime) GetUnit() Lifetime_Unit {
	if m != nil {
		return m.Unit
	}
	return Lifetime_Unlimited
}

func (m *Lifetime) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type Tx struct {
	// Type describes target of transaction
	Type Tx_Type `protobuf:"varint,1,opt,name=type,proto3,enum=accounting.Tx_Type" json:"type,omitempty"`
	// From describes sender of funds
	From string `protobuf:"bytes,2,opt,name=From,proto3" json:"From,omitempty"`
	// To describes receiver of funds
	To string `protobuf:"bytes,3,opt,name=To,proto3" json:"To,omitempty"`
	// Amount describes amount of funds
	Amount *decimal.Decimal `protobuf:"bytes,4,opt,name=Amount,proto3" json:"Amount,omitempty"`
	// PublicKeys contains public key of sender
	PublicKeys           []byte   `protobuf:"bytes,5,opt,name=PublicKeys,proto3" json:"PublicKeys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tx) Reset()         { *m = Tx{} }
func (m *Tx) String() string { return proto.CompactTextString(m) }
func (*Tx) ProtoMessage()    {}
func (*Tx) Descriptor() ([]byte, []int) {
	return fileDescriptor_437c556d7375b726, []int{5}
}
func (m *Tx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Tx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tx.Merge(m, src)
}
func (m *Tx) XXX_Size() int {
	return m.Size()
}
func (m *Tx) XXX_DiscardUnknown() {
	xxx_messageInfo_Tx.DiscardUnknown(m)
}

var xxx_messageInfo_Tx proto.InternalMessageInfo

func (m *Tx) GetType() Tx_Type {
	if m != nil {
		return m.Type
	}
	return Tx_Unknown
}

func (m *Tx) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Tx) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *Tx) GetAmount() *decimal.Decimal {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *Tx) GetPublicKeys() []byte {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

type Settlement struct {
	// Epoch contains an epoch when settlement was accepted
	Epoch uint64 `protobuf:"varint,1,opt,name=Epoch,proto3" json:"Epoch,omitempty"`
	// Transactions is a set of transactions
	Transactions         []*Settlement_Tx `protobuf:"bytes,2,rep,name=Transactions,proto3" json:"Transactions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Settlement) Reset()         { *m = Settlement{} }
func (m *Settlement) String() string { return proto.CompactTextString(m) }
func (*Settlement) ProtoMessage()    {}
func (*Settlement) Descriptor() ([]byte, []int) {
	return fileDescriptor_437c556d7375b726, []int{6}
}
func (m *Settlement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Settlement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Settlement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Settlement.Merge(m, src)
}
func (m *Settlement) XXX_Size() int {
	return m.Size()
}
func (m *Settlement) XXX_DiscardUnknown() {
	xxx_messageInfo_Settlement.DiscardUnknown(m)
}

var xxx_messageInfo_Settlement proto.InternalMessageInfo

func (m *Settlement) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *Settlement) GetTransactions() []*Settlement_Tx {
	if m != nil {
		return m.Transactions
	}
	return nil
}

type Settlement_Receiver struct {
	// To is the address of funds recipient
	To string `protobuf:"bytes,1,opt,name=To,proto3" json:"To,omitempty"`
	// Amount is the amount of funds that will be sent
	Amount               *decimal.Decimal `protobuf:"bytes,2,opt,name=Amount,proto3" json:"Amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Settlement_Receiver) Reset()         { *m = Settlement_Receiver{} }
func (m *Settlement_Receiver) String() string { return proto.CompactTextString(m) }
func (*Settlement_Receiver) ProtoMessage()    {}
func (*Settlement_Receiver) Descriptor() ([]byte, []int) {
	return fileDescriptor_437c556d7375b726, []int{6, 0}
}
func (m *Settlement_Receiver) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Settlement_Receiver) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Settlement_Receiver) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Settlement_Receiver.Merge(m, src)
}
func (m *Settlement_Receiver) XXX_Size() int {
	return m.Size()
}
func (m *Settlement_Receiver) XXX_DiscardUnknown() {
	xxx_messageInfo_Settlement_Receiver.DiscardUnknown(m)
}

var xxx_messageInfo_Settlement_Receiver proto.InternalMessageInfo

func (m *Settlement_Receiver) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *Settlement_Receiver) GetAmount() *decimal.Decimal {
	if m != nil {
		return m.Amount
	}
	return nil
}

type Settlement_Container struct {
	// CID is container identifier
	CID CID `protobuf:"bytes,1,opt,name=CID,proto3,customtype=CID" json:"CID"`
	// SGIDs is a set of storage groups that successfully passed the audit
	SGIDs                []SGID   `protobuf:"bytes,2,rep,name=SGIDs,proto3,customtype=SGID" json:"SGIDs"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Settlement_Container) Reset()         { *m = Settlement_Container{} }
func (m *Settlement_Container) String() string { return proto.CompactTextString(m) }
func (*Settlement_Container) ProtoMessage()    {}
func (*Settlement_Container) Descriptor() ([]byte, []int) {
	return fileDescriptor_437c556d7375b726, []int{6, 1}
}
func (m *Settlement_Container) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Settlement_Container) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Settlement_Container) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Settlement_Container.Merge(m, src)
}
func (m *Settlement_Container) XXX_Size() int {
	return m.Size()
}
func (m *Settlement_Container) XXX_DiscardUnknown() {
	xxx_messageInfo_Settlement_Container.DiscardUnknown(m)
}

var xxx_messageInfo_Settlement_Container proto.InternalMessageInfo

type Settlement_Tx struct {
	// From is the address of the sender of funds
	From string `protobuf:"bytes,1,opt,name=From,proto3" json:"From,omitempty"`
	// Container that successfully had passed the audit
	Container Settlement_Container `protobuf:"bytes,2,opt,name=Container,proto3" json:"Container"`
	// Receivers is a set of addresses of funds recipients
	Receivers            []Settlement_Receiver `protobuf:"bytes,3,rep,name=Receivers,proto3" json:"Receivers"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Settlement_Tx) Reset()         { *m = Settlement_Tx{} }
func (m *Settlement_Tx) String() string { return proto.CompactTextString(m) }
func (*Settlement_Tx) ProtoMessage()    {}
func (*Settlement_Tx) Descriptor() ([]byte, []int) {
	return fileDescriptor_437c556d7375b726, []int{6, 2}
}
func (m *Settlement_Tx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Settlement_Tx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Settlement_Tx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Settlement_Tx.Merge(m, src)
}
func (m *Settlement_Tx) XXX_Size() int {
	return m.Size()
}
func (m *Settlement_Tx) XXX_DiscardUnknown() {
	xxx_messageInfo_Settlement_Tx.DiscardUnknown(m)
}

var xxx_messageInfo_Settlement_Tx proto.InternalMessageInfo

func (m *Settlement_Tx) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Settlement_Tx) GetContainer() Settlement_Container {
	if m != nil {
		return m.Container
	}
	return Settlement_Container{}
}

func (m *Settlement_Tx) GetReceivers() []Settlement_Receiver {
	if m != nil {
		return m.Receivers
	}
	return nil
}

type ContainerCreateTarget struct {
	// CID is container identifier
	CID                  CID      `protobuf:"bytes,1,opt,name=CID,proto3,customtype=CID" json:"CID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContainerCreateTarget) Reset()         { *m = ContainerCreateTarget{} }
func (m *ContainerCreateTarget) String() string { return proto.CompactTextString(m) }
func (*ContainerCreateTarget) ProtoMessage()    {}
func (*ContainerCreateTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_437c556d7375b726, []int{7}
}
func (m *ContainerCreateTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerCreateTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ContainerCreateTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerCreateTarget.Merge(m, src)
}
func (m *ContainerCreateTarget) XXX_Size() int {
	return m.Size()
}
func (m *ContainerCreateTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerCreateTarget.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerCreateTarget proto.InternalMessageInfo

type WithdrawTarget struct {
	// Cheque is a string representation of cheque id
	Cheque               string   `protobuf:"bytes,1,opt,name=Cheque,proto3" json:"Cheque,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WithdrawTarget) Reset()         { *m = WithdrawTarget{} }
func (m *WithdrawTarget) String() string { return proto.CompactTextString(m) }
func (*WithdrawTarget) ProtoMessage()    {}
func (*WithdrawTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_437c556d7375b726, []int{8}
}
func (m *WithdrawTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WithdrawTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawTarget.Merge(m, src)
}
func (m *WithdrawTarget) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawTarget.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawTarget proto.InternalMessageInfo

func (m *WithdrawTarget) GetCheque() string {
	if m != nil {
		return m.Cheque
	}
	return ""
}

func init() {
	proto.RegisterEnum("accounting.Lifetime_Unit", Lifetime_Unit_name, Lifetime_Unit_value)
	proto.RegisterEnum("accounting.Tx_Type", Tx_Type_name, Tx_Type_value)
	proto.RegisterType((*Account)(nil), "accounting.Account")
	proto.RegisterType((*LockTarget)(nil), "accounting.LockTarget")
	proto.RegisterType((*Balances)(nil), "accounting.Balances")
	proto.RegisterType((*PayIO)(nil), "accounting.PayIO")
	proto.RegisterType((*Lifetime)(nil), "accounting.Lifetime")
	proto.RegisterType((*Tx)(nil), "accounting.Tx")
	proto.RegisterType((*Settlement)(nil), "accounting.Settlement")
	proto.RegisterType((*Settlement_Receiver)(nil), "accounting.Settlement.Receiver")
	proto.RegisterType((*Settlement_Container)(nil), "accounting.Settlement.Container")
	proto.RegisterType((*Settlement_Tx)(nil), "accounting.Settlement.Tx")
	proto.RegisterType((*ContainerCreateTarget)(nil), "accounting.ContainerCreateTarget")
	proto.RegisterType((*WithdrawTarget)(nil), "accounting.WithdrawTarget")
}

func init() { proto.RegisterFile("accounting/types.proto", fileDescriptor_437c556d7375b726) }

var fileDescriptor_437c556d7375b726 = []byte{
	// 821 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x55, 0x4d, 0x6f, 0xe3, 0x44,
	0x18, 0xce, 0x38, 0x69, 0x3e, 0xde, 0x64, 0x83, 0x35, 0xbb, 0x5b, 0x85, 0x48, 0xa4, 0xc1, 0xe2,
	0x10, 0x84, 0xea, 0x88, 0xae, 0x68, 0xb9, 0x70, 0x88, 0x13, 0xca, 0x56, 0xac, 0xba, 0xd5, 0xd4,
	0x05, 0x01, 0x27, 0xd7, 0x99, 0xa6, 0x56, 0x93, 0x99, 0x60, 0x8f, 0xfb, 0xf1, 0x27, 0x38, 0x73,
	0xe1, 0xc4, 0x8f, 0xe0, 0x2f, 0xec, 0x11, 0x6e, 0x88, 0x43, 0x85, 0xc2, 0x1f, 0x41, 0x33, 0x1e,
	0x3b, 0x76, 0x95, 0xc0, 0x25, 0x79, 0x3f, 0x9e, 0xf7, 0x99, 0xf7, 0x6b, 0xc6, 0xb0, 0xeb, 0xf9,
	0x3e, 0x8f, 0x99, 0x08, 0xd8, 0x6c, 0x28, 0x1e, 0x96, 0x34, 0xb2, 0x97, 0x21, 0x17, 0x1c, 0xc3,
	0xda, 0xde, 0x7d, 0x39, 0xa5, 0x7e, 0xb0, 0xf0, 0xe6, 0x43, 0xfd, 0x9f, 0x40, 0xba, 0xfb, 0xb3,
	0x40, 0x5c, 0xc7, 0x97, 0xb6, 0xcf, 0x17, 0xc3, 0x19, 0x9f, 0xf1, 0xa1, 0x32, 0x5f, 0xc6, 0x57,
	0x4a, 0x53, 0x8a, 0x92, 0x12, 0xb8, 0xf5, 0x87, 0x01, 0xb5, 0x51, 0x42, 0x8a, 0x3f, 0x86, 0xda,
	0xdb, 0x3b, 0x46, 0xc3, 0x93, 0x49, 0x07, 0xf5, 0xd1, 0xa0, 0xe5, 0xbc, 0xf7, 0xee, 0x71, 0xaf,
	0xf4, 0xd7, 0xe3, 0x5e, 0x6a, 0x26, 0xa9, 0x80, 0x3b, 0x50, 0x1b, 0x4d, 0xa7, 0x21, 0x8d, 0xa2,
	0x8e, 0xd1, 0x47, 0x83, 0x06, 0x49, 0x55, 0xfc, 0x11, 0x3c, 0x3b, 0xf3, 0x42, 0xca, 0x44, 0xea,
	0x2f, 0x2b, 0x7f, 0xd1, 0x88, 0x0f, 0xa0, 0x39, 0xf2, 0x45, 0x70, 0x4b, 0x8f, 0x63, 0x36, 0x8d,
	0x3a, 0x95, 0x3e, 0x1a, 0x34, 0x0f, 0x4c, 0x3b, 0x2d, 0x65, 0x92, 0xfc, 0x93, 0x3c, 0x08, 0x1f,
	0x42, 0xfd, 0x4d, 0x70, 0x45, 0x45, 0xb0, 0xa0, 0x9d, 0x1d, 0x15, 0xf0, 0xc2, 0x5e, 0xf7, 0xc3,
	0x4e, 0x7d, 0x4e, 0x45, 0x66, 0x4d, 0x32, 0x2c, 0x3e, 0x04, 0x78, 0xc3, 0xfd, 0x1b, 0xd7, 0x0b,
	0x67, 0x54, 0x74, 0xaa, 0x2a, 0x72, 0xb7, 0x10, 0x99, 0x79, 0x49, 0x0e, 0x89, 0x8f, 0xa0, 0x25,
	0x35, 0xdd, 0x9d, 0xa8, 0x53, 0xeb, 0x97, 0x07, 0xcd, 0x83, 0xe7, 0xf9, 0x48, 0xed, 0x23, 0x05,
	0xa0, 0xf5, 0x1b, 0xca, 0x9f, 0x88, 0x27, 0xd0, 0xfe, 0x36, 0x10, 0xd7, 0xd3, 0xd0, 0xbb, 0xd3,
	0x39, 0x20, 0x95, 0x43, 0x37, 0xcf, 0x54, 0x44, 0xbc, 0x2e, 0x91, 0x27, 0x31, 0xf8, 0x3b, 0x78,
	0x39, 0xe6, 0x4c, 0x78, 0x01, 0xa3, 0xe1, 0x38, 0xa4, 0x9e, 0xa0, 0x9a, 0xcc, 0x50, 0x64, 0x1f,
	0xe6, 0xc9, 0x36, 0x02, 0x5f, 0x97, 0xc8, 0x66, 0x06, 0xa7, 0x0e, 0xd5, 0x44, 0xb2, 0x46, 0x50,
	0x77, 0xbc, 0xb9, 0xc7, 0x7c, 0x1a, 0xe1, 0xcf, 0xa0, 0x9e, 0x95, 0x8e, 0xb6, 0x96, 0x9e, 0x76,
	0x3b, 0x2b, 0xfe, 0x07, 0xd8, 0x39, 0xf3, 0x1e, 0x4e, 0xde, 0xca, 0x15, 0x71, 0xe6, 0xdc, 0xbf,
	0xd1, 0xdb, 0x54, 0x21, 0xa9, 0x8a, 0x3f, 0x87, 0x96, 0x1b, 0x7a, 0x2c, 0xf2, 0x7c, 0x11, 0x70,
	0x26, 0x37, 0x48, 0xb2, 0xb7, 0xf3, 0xec, 0xee, 0xbd, 0x26, 0x2e, 0x20, 0xad, 0x9f, 0xd0, 0x7a,
	0x07, 0xf0, 0x11, 0x54, 0x62, 0x16, 0x24, 0xdd, 0x6c, 0x1f, 0xbc, 0xbf, 0x69, 0x17, 0xec, 0x0b,
	0x16, 0x08, 0xa7, 0xbe, 0x7a, 0xdc, 0xab, 0x48, 0x89, 0xa8, 0x00, 0xfc, 0x02, 0x76, 0xbe, 0xf1,
	0xe6, 0x31, 0x55, 0xad, 0x2b, 0x93, 0x44, 0xb1, 0x5e, 0x81, 0xc2, 0xe0, 0x67, 0xd0, 0xb8, 0x60,
	0xf3, 0x60, 0x11, 0x08, 0x3a, 0x35, 0x4b, 0xb8, 0x0d, 0x70, 0x4a, 0xf9, 0xf1, 0xf9, 0x97, 0x4b,
	0xee, 0x5f, 0x9b, 0x08, 0xb7, 0xa0, 0x7e, 0x4a, 0xb9, 0x2a, 0xc5, 0x34, 0xac, 0x47, 0x04, 0x86,
	0x7b, 0x8f, 0x3f, 0x85, 0x8a, 0xbc, 0xa6, 0x3a, 0x95, 0xe7, 0xc5, 0x4a, 0x6c, 0xf7, 0x61, 0x49,
	0x93, 0x24, 0xa4, 0x44, 0x14, 0x14, 0x63, 0xa8, 0x1c, 0x87, 0x7c, 0xa1, 0xaf, 0x8f, 0x92, 0x71,
	0x1b, 0x0c, 0x97, 0xeb, 0x0b, 0x63, 0xb8, 0x1c, 0x0f, 0xa0, 0x3a, 0x5a, 0x48, 0xa2, 0xad, 0x17,
	0x44, 0xfb, 0x71, 0x0f, 0xe0, 0x2c, 0xbe, 0x9c, 0x07, 0xfe, 0xd7, 0xf4, 0x21, 0x52, 0xb7, 0xa3,
	0x45, 0x72, 0x16, 0xeb, 0x08, 0xd4, 0xd9, 0xb8, 0x09, 0xb5, 0x0b, 0x76, 0xc3, 0xf8, 0x1d, 0x33,
	0x4b, 0xb2, 0x94, 0x74, 0xc9, 0x4c, 0x84, 0x1b, 0x7a, 0x70, 0xa6, 0x21, 0xc5, 0x13, 0xc6, 0x68,
	0x68, 0x96, 0xad, 0x5f, 0xca, 0x00, 0xe7, 0x54, 0x88, 0x39, 0x5d, 0x50, 0xa6, 0x5a, 0xa7, 0x1a,
	0xa1, 0x47, 0x9a, 0x28, 0xf8, 0x8b, 0x8d, 0x03, 0x2d, 0x4c, 0x64, 0xcd, 0x61, 0xbb, 0xf7, 0xc5,
	0xa9, 0x76, 0x27, 0x50, 0x27, 0xd4, 0xa7, 0xc1, 0x2d, 0x0d, 0x75, 0x0b, 0xd0, 0x86, 0x16, 0x18,
	0xff, 0xdd, 0x82, 0xee, 0x29, 0x34, 0xb2, 0xf5, 0xc6, 0x1f, 0x40, 0x79, 0x9c, 0x3d, 0x63, 0x4d,
	0xfd, 0x8c, 0x49, 0x13, 0x91, 0x3f, 0xd8, 0x82, 0x9d, 0xf3, 0xaf, 0x4e, 0x26, 0x49, 0xa6, 0x2d,
	0xa7, 0xa5, 0x01, 0x15, 0x69, 0x24, 0x89, 0xab, 0xfb, 0x6b, 0x32, 0xda, 0x74, 0x4e, 0x28, 0x37,
	0xa7, 0x49, 0xee, 0x28, 0x9d, 0x57, 0x7f, 0x4b, 0xb1, 0x19, 0x4e, 0xef, 0x73, 0x2e, 0xc7, 0x31,
	0x34, 0xd2, 0xb2, 0xe5, 0x2b, 0x29, 0x5b, 0xb6, 0xb7, 0x85, 0x25, 0xc5, 0xa5, 0x24, 0x59, 0x9c,
	0x75, 0xb8, 0xe5, 0x59, 0xf8, 0x9f, 0x0e, 0x58, 0x83, 0xa7, 0x8f, 0x12, 0xde, 0x85, 0xea, 0xf8,
	0x9a, 0xfe, 0x18, 0x53, 0x5d, 0xaa, 0xd6, 0x9c, 0xd1, 0xbb, 0x55, 0x0f, 0xfd, 0xbe, 0xea, 0xa1,
	0x3f, 0x57, 0x3d, 0xf4, 0xf7, 0xaa, 0x87, 0x7e, 0xfe, 0xa7, 0x57, 0xfa, 0xfe, 0x93, 0xdc, 0x67,
	0x86, 0x45, 0x4b, 0xdf, 0xdf, 0x9f, 0xd2, 0xdb, 0x21, 0xa3, 0xfc, 0x2a, 0xda, 0x4f, 0x3e, 0x32,
	0xeb, 0x4a, 0x2e, 0xab, 0xca, 0xf2, 0xea, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x3c, 0x2d, 0x7e,
	0x6b, 0xd7, 0x06, 0x00, 0x00,
}

func (m *Account) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Account) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LockAccounts) > 0 {
		for iNdEx := len(m.LockAccounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LockAccounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.LockTarget != nil {
		{
			size, err := m.LockTarget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	{
		size, err := m.Lifetime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.ActiveFunds != nil {
		{
			size, err := m.ActiveFunds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ParentAddress) > 0 {
		i -= len(m.ParentAddress)
		copy(dAtA[i:], m.ParentAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ParentAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.OwnerID.Size()
		i -= size
		if _, err := m.OwnerID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LockTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Target != nil {
		{
			size := m.Target.Size()
			i -= size
			if _, err := m.Target.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LockTarget_WithdrawTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockTarget_WithdrawTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WithdrawTarget != nil {
		{
			size, err := m.WithdrawTarget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *LockTarget_ContainerCreateTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockTarget_ContainerCreateTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ContainerCreateTarget != nil {
		{
			size, err := m.ContainerCreateTarget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Balances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Balances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Balances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Accounts) > 0 {
		for iNdEx := len(m.Accounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Accounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PayIO) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayIO) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayIO) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Transactions) > 0 {
		for iNdEx := len(m.Transactions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Transactions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BlockID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Lifetime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Lifetime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Lifetime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if m.Unit != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Unit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PublicKeys) > 0 {
		i -= len(m.PublicKeys)
		copy(dAtA[i:], m.PublicKeys)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKeys)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Amount != nil {
		{
			size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Settlement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Settlement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Settlement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Transactions) > 0 {
		for iNdEx := len(m.Transactions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Transactions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Epoch != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Settlement_Receiver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Settlement_Receiver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Settlement_Receiver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Amount != nil {
		{
			size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Settlement_Container) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Settlement_Container) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Settlement_Container) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SGIDs) > 0 {
		for iNdEx := len(m.SGIDs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.SGIDs[iNdEx].Size()
				i -= size
				if _, err := m.SGIDs[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.CID.Size()
		i -= size
		if _, err := m.CID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Settlement_Tx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Settlement_Tx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Settlement_Tx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Receivers) > 0 {
		for iNdEx := len(m.Receivers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Receivers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.Container.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerCreateTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerCreateTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerCreateTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size := m.CID.Size()
		i -= size
		if _, err := m.CID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WithdrawTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cheque) > 0 {
		i -= len(m.Cheque)
		copy(dAtA[i:], m.Cheque)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Cheque)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Account) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OwnerID.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ParentAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ActiveFunds != nil {
		l = m.ActiveFunds.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Lifetime.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.LockTarget != nil {
		l = m.LockTarget.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.LockAccounts) > 0 {
		for _, e := range m.LockAccounts {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Target != nil {
		n += m.Target.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockTarget_WithdrawTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithdrawTarget != nil {
		l = m.WithdrawTarget.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LockTarget_ContainerCreateTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContainerCreateTarget != nil {
		l = m.ContainerCreateTarget.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Balances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for _, e := range m.Accounts {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PayIO) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockID != 0 {
		n += 1 + sovTypes(uint64(m.BlockID))
	}
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Lifetime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Unit != 0 {
		n += 1 + sovTypes(uint64(m.Unit))
	}
	if m.Value != 0 {
		n += 1 + sovTypes(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Amount != nil {
		l = m.Amount.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicKeys)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Settlement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovTypes(uint64(m.Epoch))
	}
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Settlement_Receiver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Amount != nil {
		l = m.Amount.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Settlement_Container) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CID.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.SGIDs) > 0 {
		for _, e := range m.SGIDs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Settlement_Tx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Container.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.Receivers) > 0 {
		for _, e := range m.Receivers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerCreateTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CID.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WithdrawTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cheque)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Account) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OwnerID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveFunds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActiveFunds == nil {
				m.ActiveFunds = &decimal.Decimal{}
			}
			if err := m.ActiveFunds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lifetime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lifetime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LockTarget == nil {
				m.LockTarget = &LockTarget{}
			}
			if err := m.LockTarget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockAccounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockAccounts = append(m.LockAccounts, &Account{})
			if err := m.LockAccounts[len(m.LockAccounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawTarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WithdrawTarget{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &LockTarget_WithdrawTarget{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerCreateTarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContainerCreateTarget{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &LockTarget_ContainerCreateTarget{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Balances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Balances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Balances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accounts = append(m.Accounts, Account{})
			if err := m.Accounts[len(m.Accounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayIO) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayIO: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayIO: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			m.BlockID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, Tx{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Lifetime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lifetime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lifetime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			m.Unit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unit |= Lifetime_Unit(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Tx_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Amount == nil {
				m.Amount = &decimal.Decimal{}
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeys = append(m.PublicKeys[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKeys == nil {
				m.PublicKeys = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Settlement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Settlement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Settlement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &Settlement_Tx{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Settlement_Receiver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Receiver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Receiver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Amount == nil {
				m.Amount = &decimal.Decimal{}
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Settlement_Container) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Container: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Container: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SGIDs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v SGID
			m.SGIDs = append(m.SGIDs, v)
			if err := m.SGIDs[len(m.SGIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Settlement_Tx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Container.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receivers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receivers = append(m.Receivers, Settlement_Receiver{})
			if err := m.Receivers[len(m.Receivers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerCreateTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerCreateTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerCreateTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cheque", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cheque = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
