// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: object/types.proto

package object

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	refs "github.com/nspcc-dev/neofs-proto/refs"
	session "github.com/nspcc-dev/neofs-proto/session"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Link_Type int32

const (
	Link_Unknown      Link_Type = 0
	Link_Parent       Link_Type = 1
	Link_Previous     Link_Type = 2
	Link_Next         Link_Type = 3
	Link_Child        Link_Type = 4
	Link_StorageGroup Link_Type = 5
)

var Link_Type_name = map[int32]string{
	0: "Unknown",
	1: "Parent",
	2: "Previous",
	3: "Next",
	4: "Child",
	5: "StorageGroup",
}

var Link_Type_value = map[string]int32{
	"Unknown":      0,
	"Parent":       1,
	"Previous":     2,
	"Next":         3,
	"Child":        4,
	"StorageGroup": 5,
}

func (x Link_Type) String() string {
	return proto.EnumName(Link_Type_name, int32(x))
}

func (Link_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{7, 0}
}

type Transform_Type int32

const (
	Transform_Unknown Transform_Type = 0
	Transform_Split   Transform_Type = 1
	Transform_Sign    Transform_Type = 2
	Transform_Mould   Transform_Type = 3
)

var Transform_Type_name = map[int32]string{
	0: "Unknown",
	1: "Split",
	2: "Sign",
	3: "Mould",
}

var Transform_Type_value = map[string]int32{
	"Unknown": 0,
	"Split":   1,
	"Sign":    2,
	"Mould":   3,
}

func (x Transform_Type) String() string {
	return proto.EnumName(Transform_Type_name, int32(x))
}

func (Transform_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{8, 0}
}

type StorageGroup_Lifetime_Unit int32

const (
	StorageGroup_Lifetime_Unlimited  StorageGroup_Lifetime_Unit = 0
	StorageGroup_Lifetime_NeoFSEpoch StorageGroup_Lifetime_Unit = 1
	StorageGroup_Lifetime_UnixTime   StorageGroup_Lifetime_Unit = 2
)

var StorageGroup_Lifetime_Unit_name = map[int32]string{
	0: "Unlimited",
	1: "NeoFSEpoch",
	2: "UnixTime",
}

var StorageGroup_Lifetime_Unit_value = map[string]int32{
	"Unlimited":  0,
	"NeoFSEpoch": 1,
	"UnixTime":   2,
}

func (x StorageGroup_Lifetime_Unit) String() string {
	return proto.EnumName(StorageGroup_Lifetime_Unit_name, int32(x))
}

func (StorageGroup_Lifetime_Unit) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{10, 0, 0}
}

type Range struct {
	Offset               uint64   `protobuf:"varint,1,opt,name=Offset,proto3" json:"Offset,omitempty"`
	Length               uint64   `protobuf:"varint,2,opt,name=Length,proto3" json:"Length,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Range) Reset()         { *m = Range{} }
func (m *Range) String() string { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()    {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{0}
}
func (m *Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(m, src)
}
func (m *Range) XXX_Size() int {
	return m.Size()
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

func (m *Range) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *Range) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

type UserHeader struct {
	Key                  string   `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserHeader) Reset()         { *m = UserHeader{} }
func (m *UserHeader) String() string { return proto.CompactTextString(m) }
func (*UserHeader) ProtoMessage()    {}
func (*UserHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{1}
}
func (m *UserHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UserHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserHeader.Merge(m, src)
}
func (m *UserHeader) XXX_Size() int {
	return m.Size()
}
func (m *UserHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_UserHeader.DiscardUnknown(m)
}

var xxx_messageInfo_UserHeader proto.InternalMessageInfo

func (m *UserHeader) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *UserHeader) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Header struct {
	// Types that are valid to be assigned to Value:
	//	*Header_Link
	//	*Header_Redirect
	//	*Header_UserHeader
	//	*Header_Transform
	//	*Header_Tombstone
	//	*Header_Verify
	//	*Header_HomoHash
	//	*Header_PayloadChecksum
	//	*Header_Integrity
	//	*Header_StorageGroup
	Value                isHeader_Value `protobuf_oneof:"Value"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{2}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

type isHeader_Value interface {
	isHeader_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Header_Link struct {
	Link *Link `protobuf:"bytes,1,opt,name=Link,proto3,oneof" json:"Link,omitempty"`
}
type Header_Redirect struct {
	Redirect *refs.Address `protobuf:"bytes,2,opt,name=Redirect,proto3,oneof" json:"Redirect,omitempty"`
}
type Header_UserHeader struct {
	UserHeader *UserHeader `protobuf:"bytes,3,opt,name=UserHeader,proto3,oneof" json:"UserHeader,omitempty"`
}
type Header_Transform struct {
	Transform *Transform `protobuf:"bytes,4,opt,name=Transform,proto3,oneof" json:"Transform,omitempty"`
}
type Header_Tombstone struct {
	Tombstone *Tombstone `protobuf:"bytes,5,opt,name=Tombstone,proto3,oneof" json:"Tombstone,omitempty"`
}
type Header_Verify struct {
	Verify *session.VerificationHeader `protobuf:"bytes,6,opt,name=Verify,proto3,oneof" json:"Verify,omitempty"`
}
type Header_HomoHash struct {
	HomoHash Hash `protobuf:"bytes,7,opt,name=HomoHash,proto3,oneof,customtype=Hash" json:"HomoHash,omitempty"`
}
type Header_PayloadChecksum struct {
	PayloadChecksum []byte `protobuf:"bytes,8,opt,name=PayloadChecksum,proto3,oneof" json:"PayloadChecksum,omitempty"`
}
type Header_Integrity struct {
	Integrity *IntegrityHeader `protobuf:"bytes,9,opt,name=Integrity,proto3,oneof" json:"Integrity,omitempty"`
}
type Header_StorageGroup struct {
	StorageGroup *StorageGroup `protobuf:"bytes,10,opt,name=StorageGroup,proto3,oneof" json:"StorageGroup,omitempty"`
}

func (*Header_Link) isHeader_Value()            {}
func (*Header_Redirect) isHeader_Value()        {}
func (*Header_UserHeader) isHeader_Value()      {}
func (*Header_Transform) isHeader_Value()       {}
func (*Header_Tombstone) isHeader_Value()       {}
func (*Header_Verify) isHeader_Value()          {}
func (*Header_HomoHash) isHeader_Value()        {}
func (*Header_PayloadChecksum) isHeader_Value() {}
func (*Header_Integrity) isHeader_Value()       {}
func (*Header_StorageGroup) isHeader_Value()    {}

func (m *Header) GetValue() isHeader_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Header) GetLink() *Link {
	if x, ok := m.GetValue().(*Header_Link); ok {
		return x.Link
	}
	return nil
}

func (m *Header) GetRedirect() *refs.Address {
	if x, ok := m.GetValue().(*Header_Redirect); ok {
		return x.Redirect
	}
	return nil
}

func (m *Header) GetUserHeader() *UserHeader {
	if x, ok := m.GetValue().(*Header_UserHeader); ok {
		return x.UserHeader
	}
	return nil
}

func (m *Header) GetTransform() *Transform {
	if x, ok := m.GetValue().(*Header_Transform); ok {
		return x.Transform
	}
	return nil
}

func (m *Header) GetTombstone() *Tombstone {
	if x, ok := m.GetValue().(*Header_Tombstone); ok {
		return x.Tombstone
	}
	return nil
}

func (m *Header) GetVerify() *session.VerificationHeader {
	if x, ok := m.GetValue().(*Header_Verify); ok {
		return x.Verify
	}
	return nil
}

func (m *Header) GetPayloadChecksum() []byte {
	if x, ok := m.GetValue().(*Header_PayloadChecksum); ok {
		return x.PayloadChecksum
	}
	return nil
}

func (m *Header) GetIntegrity() *IntegrityHeader {
	if x, ok := m.GetValue().(*Header_Integrity); ok {
		return x.Integrity
	}
	return nil
}

func (m *Header) GetStorageGroup() *StorageGroup {
	if x, ok := m.GetValue().(*Header_StorageGroup); ok {
		return x.StorageGroup
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Header) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Header_Link)(nil),
		(*Header_Redirect)(nil),
		(*Header_UserHeader)(nil),
		(*Header_Transform)(nil),
		(*Header_Tombstone)(nil),
		(*Header_Verify)(nil),
		(*Header_HomoHash)(nil),
		(*Header_PayloadChecksum)(nil),
		(*Header_Integrity)(nil),
		(*Header_StorageGroup)(nil),
	}
}

type Tombstone struct {
	Epoch                uint64   `protobuf:"varint,1,opt,name=Epoch,proto3" json:"Epoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tombstone) Reset()         { *m = Tombstone{} }
func (m *Tombstone) String() string { return proto.CompactTextString(m) }
func (*Tombstone) ProtoMessage()    {}
func (*Tombstone) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{3}
}
func (m *Tombstone) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tombstone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Tombstone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tombstone.Merge(m, src)
}
func (m *Tombstone) XXX_Size() int {
	return m.Size()
}
func (m *Tombstone) XXX_DiscardUnknown() {
	xxx_messageInfo_Tombstone.DiscardUnknown(m)
}

var xxx_messageInfo_Tombstone proto.InternalMessageInfo

func (m *Tombstone) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

type SystemHeader struct {
	Version              uint64        `protobuf:"varint,1,opt,name=Version,proto3" json:"Version,omitempty"`
	PayloadLength        uint64        `protobuf:"varint,2,opt,name=PayloadLength,proto3" json:"PayloadLength,omitempty"`
	ID                   ID            `protobuf:"bytes,3,opt,name=ID,proto3,customtype=ID" json:"ID"`
	OwnerID              OwnerID       `protobuf:"bytes,4,opt,name=OwnerID,proto3,customtype=OwnerID" json:"OwnerID"`
	CID                  CID           `protobuf:"bytes,5,opt,name=CID,proto3,customtype=CID" json:"CID"`
	CreatedAt            CreationPoint `protobuf:"bytes,6,opt,name=CreatedAt,proto3" json:"CreatedAt"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SystemHeader) Reset()         { *m = SystemHeader{} }
func (m *SystemHeader) String() string { return proto.CompactTextString(m) }
func (*SystemHeader) ProtoMessage()    {}
func (*SystemHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{4}
}
func (m *SystemHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SystemHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemHeader.Merge(m, src)
}
func (m *SystemHeader) XXX_Size() int {
	return m.Size()
}
func (m *SystemHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemHeader.DiscardUnknown(m)
}

var xxx_messageInfo_SystemHeader proto.InternalMessageInfo

func (m *SystemHeader) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *SystemHeader) GetPayloadLength() uint64 {
	if m != nil {
		return m.PayloadLength
	}
	return 0
}

func (m *SystemHeader) GetCreatedAt() CreationPoint {
	if m != nil {
		return m.CreatedAt
	}
	return CreationPoint{}
}

type CreationPoint struct {
	UnixTime             int64    `protobuf:"varint,1,opt,name=UnixTime,proto3" json:"UnixTime,omitempty"`
	Epoch                uint64   `protobuf:"varint,2,opt,name=Epoch,proto3" json:"Epoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreationPoint) Reset()         { *m = CreationPoint{} }
func (m *CreationPoint) String() string { return proto.CompactTextString(m) }
func (*CreationPoint) ProtoMessage()    {}
func (*CreationPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{5}
}
func (m *CreationPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreationPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreationPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreationPoint.Merge(m, src)
}
func (m *CreationPoint) XXX_Size() int {
	return m.Size()
}
func (m *CreationPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_CreationPoint.DiscardUnknown(m)
}

var xxx_messageInfo_CreationPoint proto.InternalMessageInfo

func (m *CreationPoint) GetUnixTime() int64 {
	if m != nil {
		return m.UnixTime
	}
	return 0
}

func (m *CreationPoint) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

type IntegrityHeader struct {
	HeadersChecksum      []byte   `protobuf:"bytes,1,opt,name=HeadersChecksum,proto3" json:"HeadersChecksum,omitempty"`
	ChecksumSignature    []byte   `protobuf:"bytes,2,opt,name=ChecksumSignature,proto3" json:"ChecksumSignature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IntegrityHeader) Reset()         { *m = IntegrityHeader{} }
func (m *IntegrityHeader) String() string { return proto.CompactTextString(m) }
func (*IntegrityHeader) ProtoMessage()    {}
func (*IntegrityHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{6}
}
func (m *IntegrityHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntegrityHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IntegrityHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntegrityHeader.Merge(m, src)
}
func (m *IntegrityHeader) XXX_Size() int {
	return m.Size()
}
func (m *IntegrityHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_IntegrityHeader.DiscardUnknown(m)
}

var xxx_messageInfo_IntegrityHeader proto.InternalMessageInfo

func (m *IntegrityHeader) GetHeadersChecksum() []byte {
	if m != nil {
		return m.HeadersChecksum
	}
	return nil
}

func (m *IntegrityHeader) GetChecksumSignature() []byte {
	if m != nil {
		return m.ChecksumSignature
	}
	return nil
}

type Link struct {
	Type                 Link_Type `protobuf:"varint,1,opt,name=type,proto3,enum=object.Link_Type" json:"type,omitempty"`
	ID                   ID        `protobuf:"bytes,2,opt,name=ID,proto3,customtype=ID" json:"ID"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Link) Reset()         { *m = Link{} }
func (m *Link) String() string { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()    {}
func (*Link) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{7}
}
func (m *Link) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Link) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Link) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link.Merge(m, src)
}
func (m *Link) XXX_Size() int {
	return m.Size()
}
func (m *Link) XXX_DiscardUnknown() {
	xxx_messageInfo_Link.DiscardUnknown(m)
}

var xxx_messageInfo_Link proto.InternalMessageInfo

func (m *Link) GetType() Link_Type {
	if m != nil {
		return m.Type
	}
	return Link_Unknown
}

type Transform struct {
	Type                 Transform_Type `protobuf:"varint,1,opt,name=type,proto3,enum=object.Transform_Type" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Transform) Reset()         { *m = Transform{} }
func (m *Transform) String() string { return proto.CompactTextString(m) }
func (*Transform) ProtoMessage()    {}
func (*Transform) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{8}
}
func (m *Transform) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transform) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Transform) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transform.Merge(m, src)
}
func (m *Transform) XXX_Size() int {
	return m.Size()
}
func (m *Transform) XXX_DiscardUnknown() {
	xxx_messageInfo_Transform.DiscardUnknown(m)
}

var xxx_messageInfo_Transform proto.InternalMessageInfo

func (m *Transform) GetType() Transform_Type {
	if m != nil {
		return m.Type
	}
	return Transform_Unknown
}

type Object struct {
	SystemHeader         SystemHeader `protobuf:"bytes,1,opt,name=SystemHeader,proto3" json:"SystemHeader"`
	Headers              []Header     `protobuf:"bytes,2,rep,name=Headers,proto3" json:"Headers"`
	Payload              []byte       `protobuf:"bytes,3,opt,name=Payload,proto3" json:"Payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Object) Reset()         { *m = Object{} }
func (m *Object) String() string { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()    {}
func (*Object) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{9}
}
func (m *Object) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Object) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Object) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Object.Merge(m, src)
}
func (m *Object) XXX_Size() int {
	return m.Size()
}
func (m *Object) XXX_DiscardUnknown() {
	xxx_messageInfo_Object.DiscardUnknown(m)
}

var xxx_messageInfo_Object proto.InternalMessageInfo

func (m *Object) GetSystemHeader() SystemHeader {
	if m != nil {
		return m.SystemHeader
	}
	return SystemHeader{}
}

func (m *Object) GetHeaders() []Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *Object) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type StorageGroup struct {
	ValidationDataSize   uint64                 `protobuf:"varint,1,opt,name=ValidationDataSize,proto3" json:"ValidationDataSize,omitempty"`
	ValidationHash       Hash                   `protobuf:"bytes,2,opt,name=ValidationHash,proto3,customtype=Hash" json:"ValidationHash"`
	Lifetime             *StorageGroup_Lifetime `protobuf:"bytes,3,opt,name=lifetime,proto3" json:"lifetime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *StorageGroup) Reset()         { *m = StorageGroup{} }
func (m *StorageGroup) String() string { return proto.CompactTextString(m) }
func (*StorageGroup) ProtoMessage()    {}
func (*StorageGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{10}
}
func (m *StorageGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StorageGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageGroup.Merge(m, src)
}
func (m *StorageGroup) XXX_Size() int {
	return m.Size()
}
func (m *StorageGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageGroup.DiscardUnknown(m)
}

var xxx_messageInfo_StorageGroup proto.InternalMessageInfo

func (m *StorageGroup) GetValidationDataSize() uint64 {
	if m != nil {
		return m.ValidationDataSize
	}
	return 0
}

func (m *StorageGroup) GetLifetime() *StorageGroup_Lifetime {
	if m != nil {
		return m.Lifetime
	}
	return nil
}

type StorageGroup_Lifetime struct {
	Unit                 StorageGroup_Lifetime_Unit `protobuf:"varint,1,opt,name=unit,proto3,enum=object.StorageGroup_Lifetime_Unit" json:"unit,omitempty"`
	Value                int64                      `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *StorageGroup_Lifetime) Reset()         { *m = StorageGroup_Lifetime{} }
func (m *StorageGroup_Lifetime) String() string { return proto.CompactTextString(m) }
func (*StorageGroup_Lifetime) ProtoMessage()    {}
func (*StorageGroup_Lifetime) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{10, 0}
}
func (m *StorageGroup_Lifetime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageGroup_Lifetime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StorageGroup_Lifetime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageGroup_Lifetime.Merge(m, src)
}
func (m *StorageGroup_Lifetime) XXX_Size() int {
	return m.Size()
}
func (m *StorageGroup_Lifetime) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageGroup_Lifetime.DiscardUnknown(m)
}

var xxx_messageInfo_StorageGroup_Lifetime proto.InternalMessageInfo

func (m *StorageGroup_Lifetime) GetUnit() StorageGroup_Lifetime_Unit {
	if m != nil {
		return m.Unit
	}
	return StorageGroup_Lifetime_Unlimited
}

func (m *StorageGroup_Lifetime) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func init() {
	proto.RegisterEnum("object.Link_Type", Link_Type_name, Link_Type_value)
	proto.RegisterEnum("object.Transform_Type", Transform_Type_name, Transform_Type_value)
	proto.RegisterEnum("object.StorageGroup_Lifetime_Unit", StorageGroup_Lifetime_Unit_name, StorageGroup_Lifetime_Unit_value)
	proto.RegisterType((*Range)(nil), "object.Range")
	proto.RegisterType((*UserHeader)(nil), "object.UserHeader")
	proto.RegisterType((*Header)(nil), "object.Header")
	proto.RegisterType((*Tombstone)(nil), "object.Tombstone")
	proto.RegisterType((*SystemHeader)(nil), "object.SystemHeader")
	proto.RegisterType((*CreationPoint)(nil), "object.CreationPoint")
	proto.RegisterType((*IntegrityHeader)(nil), "object.IntegrityHeader")
	proto.RegisterType((*Link)(nil), "object.Link")
	proto.RegisterType((*Transform)(nil), "object.Transform")
	proto.RegisterType((*Object)(nil), "object.Object")
	proto.RegisterType((*StorageGroup)(nil), "object.StorageGroup")
	proto.RegisterType((*StorageGroup_Lifetime)(nil), "object.StorageGroup.Lifetime")
}

func init() { proto.RegisterFile("object/types.proto", fileDescriptor_02021a1d39b1aee0) }

var fileDescriptor_02021a1d39b1aee0 = []byte{
	// 996 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x55, 0xdf, 0x6e, 0xe3, 0xc4,
	0x17, 0xb6, 0x1d, 0x27, 0x71, 0x4e, 0xdd, 0xd6, 0x3b, 0xbf, 0xfd, 0x2d, 0x56, 0xd1, 0xb6, 0xc5,
	0xe2, 0x4f, 0x59, 0xa8, 0x2b, 0xda, 0x45, 0x2b, 0x90, 0x40, 0x34, 0x0d, 0x6c, 0x22, 0xca, 0xb6,
	0x9a, 0xb4, 0xbd, 0xe0, 0xce, 0x89, 0x27, 0xc9, 0xd0, 0x64, 0x26, 0xb2, 0x27, 0xbb, 0x1b, 0x1e,
	0x83, 0x1b, 0xb8, 0xe3, 0x75, 0xf6, 0x92, 0x3b, 0xd0, 0x5e, 0x44, 0x28, 0x3c, 0x00, 0x6f, 0x80,
	0xd0, 0x8c, 0xc7, 0x49, 0x9c, 0xad, 0xb8, 0x89, 0xe6, 0x9c, 0xef, 0xfb, 0x46, 0x27, 0xe7, 0x7c,
	0x67, 0x0c, 0x88, 0x77, 0x7e, 0x20, 0x5d, 0x71, 0x24, 0xa6, 0x63, 0x92, 0x86, 0xe3, 0x84, 0x0b,
	0x8e, 0x2a, 0x59, 0x6e, 0xc7, 0x4b, 0x48, 0x2f, 0x5d, 0x45, 0x76, 0xfe, 0x97, 0x92, 0x34, 0xa5,
	0x9c, 0x15, 0x92, 0x87, 0x7d, 0x2a, 0x06, 0x93, 0x4e, 0xd8, 0xe5, 0xa3, 0xa3, 0x3e, 0xef, 0xf3,
	0x23, 0x95, 0xee, 0x4c, 0x7a, 0x2a, 0x52, 0x81, 0x3a, 0x65, 0xf4, 0xe0, 0x09, 0x94, 0x71, 0xc4,
	0xfa, 0x04, 0x3d, 0x80, 0xca, 0x45, 0xaf, 0x97, 0x12, 0xe1, 0x9b, 0xfb, 0xe6, 0x81, 0x8d, 0x75,
	0x24, 0xf3, 0xe7, 0x84, 0xf5, 0xc5, 0xc0, 0xb7, 0xb2, 0x7c, 0x16, 0x05, 0x8f, 0x01, 0xae, 0x53,
	0x92, 0x34, 0x49, 0x14, 0x93, 0x04, 0x79, 0x50, 0xfa, 0x96, 0x4c, 0x95, 0xb4, 0x86, 0xe5, 0x11,
	0xdd, 0x87, 0xf2, 0x4d, 0x34, 0x9c, 0x10, 0x25, 0xab, 0xe1, 0x2c, 0x08, 0xfe, 0x29, 0x41, 0x45,
	0x4b, 0x02, 0xb0, 0xcf, 0x29, 0xbb, 0x55, 0x9a, 0x8d, 0x63, 0x37, 0xcc, 0xfe, 0x66, 0x28, 0x73,
	0x4d, 0x03, 0x2b, 0x0c, 0x7d, 0x04, 0x0e, 0x26, 0x31, 0x4d, 0x48, 0x57, 0xa8, 0x7b, 0x36, 0x8e,
	0x37, 0x43, 0xd9, 0x86, 0xf0, 0x34, 0x8e, 0x13, 0x92, 0xa6, 0x4d, 0x03, 0x2f, 0x08, 0xa8, 0x50,
	0x91, 0x5f, 0x52, 0x74, 0x94, 0x5f, 0xbb, 0x44, 0x9a, 0x06, 0x5e, 0xad, 0xfc, 0x13, 0xa8, 0x5d,
	0x25, 0x11, 0x4b, 0x7b, 0x3c, 0x19, 0xf9, 0xb6, 0x12, 0xdd, 0xcb, 0x45, 0x0b, 0xa0, 0x69, 0xe0,
	0x25, 0x4b, 0x49, 0xf8, 0xa8, 0x93, 0x0a, 0xce, 0x88, 0x5f, 0x5e, 0x93, 0xe4, 0x80, 0x92, 0xe4,
	0x01, 0xfa, 0x14, 0x2a, 0x37, 0x24, 0xa1, 0xbd, 0xa9, 0x5f, 0x51, 0xfc, 0xb7, 0x43, 0x3d, 0xbb,
	0x50, 0xa5, 0x69, 0x37, 0x12, 0x94, 0xb3, 0x45, 0x81, 0x9a, 0x8c, 0xde, 0x07, 0xa7, 0xc9, 0x47,
	0xbc, 0x19, 0xa5, 0x03, 0xbf, 0xba, 0x6f, 0x1e, 0xb8, 0x75, 0xe7, 0xf5, 0x6c, 0xcf, 0x96, 0xb1,
	0xfc, 0xeb, 0x39, 0x86, 0x1e, 0xc1, 0xf6, 0x65, 0x34, 0x1d, 0xf2, 0x28, 0x3e, 0x1b, 0x90, 0xee,
	0x6d, 0x3a, 0x19, 0xf9, 0x8e, 0xa4, 0x37, 0x0d, 0xbc, 0x0e, 0xa0, 0x27, 0x50, 0x6b, 0x31, 0x41,
	0xfa, 0x09, 0x15, 0x53, 0xbf, 0xa6, 0xaa, 0x79, 0x2b, 0xaf, 0x7e, 0x01, 0x2c, 0x2a, 0x59, 0x72,
	0xd1, 0xe7, 0xe0, 0xb6, 0x05, 0x4f, 0xa2, 0x3e, 0x79, 0x9a, 0xf0, 0xc9, 0xd8, 0x07, 0xa5, 0xbd,
	0x9f, 0x6b, 0x57, 0xb1, 0xa6, 0x81, 0x0b, 0xdc, 0x7a, 0x55, 0xbb, 0x21, 0x78, 0x67, 0xa5, 0x77,
	0xd2, 0x23, 0x5f, 0x8f, 0x79, 0x77, 0xa0, 0x2d, 0x97, 0x05, 0xc1, 0xdf, 0x26, 0xb8, 0xed, 0x69,
	0x2a, 0xc8, 0x48, 0x8f, 0xc8, 0x87, 0xea, 0x0d, 0x49, 0x64, 0xb7, 0x34, 0x31, 0x0f, 0xd1, 0xbb,
	0xb0, 0xa9, 0xff, 0x5e, 0xc1, 0xa3, 0xc5, 0x24, 0xda, 0x01, 0xab, 0xd5, 0x50, 0x86, 0x70, 0xeb,
	0xf0, 0x6a, 0xb6, 0x67, 0xbc, 0x9e, 0xed, 0x59, 0xad, 0x06, 0xb6, 0x5a, 0x0d, 0xf4, 0x21, 0x54,
	0x2f, 0x5e, 0x30, 0x92, 0xb4, 0x1a, 0x6a, 0xf8, 0x6e, 0x7d, 0x5b, 0x13, 0xf2, 0x34, 0xce, 0x0f,
	0xe8, 0x21, 0x94, 0xce, 0x5a, 0x0d, 0x35, 0x70, 0xb7, 0xbe, 0xa1, 0x69, 0x32, 0x85, 0xe5, 0x0f,
	0xfa, 0x0c, 0x6a, 0x67, 0x09, 0x89, 0x04, 0x89, 0x4f, 0x85, 0x9e, 0xf2, 0xff, 0xf3, 0xde, 0x28,
	0x80, 0x72, 0x76, 0xc9, 0x29, 0x13, 0x75, 0x5b, 0x6a, 0xf1, 0x92, 0x1d, 0x9c, 0xc2, 0x66, 0x81,
	0x81, 0x76, 0xc0, 0xb9, 0x66, 0xf4, 0xe5, 0x15, 0x1d, 0x11, 0xf5, 0x97, 0x4b, 0x78, 0x11, 0x2f,
	0x9b, 0x66, 0xad, 0x36, 0x8d, 0xc2, 0xf6, 0xda, 0xf0, 0xd0, 0x01, 0x6c, 0x67, 0xa7, 0x74, 0x61,
	0x0a, 0x79, 0x97, 0x8b, 0xd7, 0xd3, 0xe8, 0x63, 0xb8, 0x97, 0x9f, 0xdb, 0xb4, 0xcf, 0x22, 0x31,
	0x49, 0xb2, 0xbd, 0x75, 0xf1, 0x9b, 0x40, 0xf0, 0xab, 0x99, 0x6d, 0x2e, 0x7a, 0x0f, 0x6c, 0xf9,
	0xf2, 0xa8, 0x5b, 0xb7, 0x96, 0x2b, 0x20, 0xb1, 0xf0, 0x6a, 0x3a, 0x26, 0x58, 0xc1, 0xba, 0xfd,
	0xd6, 0x5d, 0xed, 0x0f, 0xae, 0xc0, 0x96, 0x4c, 0xb4, 0x01, 0xd5, 0x6b, 0x76, 0xcb, 0xf8, 0x0b,
	0xe6, 0x19, 0x08, 0xa0, 0x72, 0x19, 0x25, 0x84, 0x09, 0xcf, 0x44, 0x2e, 0x38, 0x97, 0x09, 0x79,
	0x4e, 0xf9, 0x24, 0xf5, 0x2c, 0xe4, 0x80, 0xfd, 0x8c, 0xbc, 0x14, 0x5e, 0x09, 0xd5, 0xa0, 0x7c,
	0x36, 0xa0, 0xc3, 0xd8, 0xb3, 0x91, 0x57, 0xf4, 0xa5, 0x57, 0x0e, 0x86, 0x2b, 0x3b, 0x8d, 0x1e,
	0x15, 0xaa, 0x7c, 0xf0, 0xc6, 0x6e, 0xaf, 0x94, 0x1a, 0x9c, 0xdc, 0x55, 0x4e, 0x0d, 0xca, 0xed,
	0xf1, 0x90, 0xca, 0x6a, 0x1c, 0xb0, 0x65, 0x1f, 0x3c, 0x4b, 0x26, 0xbf, 0xe3, 0x93, 0x61, 0xec,
	0x95, 0x82, 0x9f, 0x4c, 0xa8, 0x5c, 0xa8, 0x4b, 0xd1, 0x97, 0x45, 0xe7, 0xea, 0xb7, 0x6d, 0xb9,
	0x22, 0x2b, 0x98, 0x76, 0x41, 0xd1, 0xe9, 0x21, 0x54, 0xf5, 0x6c, 0x7c, 0x6b, 0xbf, 0x74, 0xb0,
	0x71, 0xbc, 0x95, 0x4b, 0x0b, 0xa2, 0x9c, 0x24, 0x37, 0x43, 0x5b, 0x3d, 0xb3, 0x37, 0xce, 0xc3,
	0xe0, 0x77, 0xab, 0xd8, 0x15, 0x14, 0x02, 0xba, 0x89, 0x86, 0x34, 0x56, 0x2e, 0x6b, 0x44, 0x22,
	0x6a, 0xd3, 0x1f, 0x89, 0xde, 0xa7, 0x3b, 0x10, 0xf4, 0x18, 0xb6, 0x96, 0x59, 0xf5, 0x00, 0x65,
	0x13, 0x74, 0xf5, 0x04, 0xd5, 0x23, 0x84, 0xd7, 0x38, 0xe8, 0x29, 0x38, 0x43, 0xda, 0x23, 0x42,
	0x1a, 0x37, 0x7b, 0x81, 0x1f, 0xde, 0xf5, 0x3e, 0x84, 0xe7, 0x9a, 0x54, 0x77, 0xe7, 0xb3, 0x3d,
	0x27, 0x8f, 0xf0, 0x42, 0xbc, 0xf3, 0xb3, 0x09, 0x8b, 0x34, 0xfa, 0x0a, 0xec, 0x09, 0xa3, 0x42,
	0x8f, 0x30, 0xf8, 0xcf, 0x1b, 0xc3, 0x6b, 0x46, 0x45, 0xdd, 0x99, 0xcf, 0xf6, 0x6c, 0x79, 0xc2,
	0x4a, 0x59, 0xfc, 0x1a, 0x95, 0xf2, 0xaf, 0xd1, 0x09, 0x28, 0x0e, 0xda, 0x84, 0xda, 0x35, 0x1b,
	0xd2, 0x11, 0x15, 0x24, 0xf6, 0x0c, 0xb4, 0x05, 0xf0, 0x8c, 0xf0, 0x6f, 0xda, 0x6a, 0xb3, 0x32,
	0x0f, 0xe6, 0xdb, 0xe7, 0x59, 0xf5, 0x2f, 0x5e, 0xcd, 0x77, 0xcd, 0xdf, 0xe6, 0xbb, 0xe6, 0x1f,
	0xf3, 0x5d, 0xf3, 0xcf, 0xf9, 0xae, 0xf9, 0xcb, 0x5f, 0xbb, 0xc6, 0xf7, 0x1f, 0xac, 0x7c, 0x76,
	0x59, 0x3a, 0xee, 0x76, 0x0f, 0x63, 0xf2, 0xfc, 0x88, 0x11, 0xde, 0x4b, 0x0f, 0xb3, 0x8f, 0x6e,
	0x56, 0x74, 0xa7, 0xa2, 0xa2, 0x93, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xbb, 0x65, 0xf4, 0xeb,
	0xeb, 0x07, 0x00, 0x00,
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Length != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x10
	}
	if m.Offset != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Header_Link) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Link) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Link != nil {
		{
			size, err := m.Link.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Header_Redirect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Redirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Redirect != nil {
		{
			size, err := m.Redirect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Header_UserHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_UserHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UserHeader != nil {
		{
			size, err := m.UserHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Header_Transform) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Transform) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Transform != nil {
		{
			size, err := m.Transform.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Header_Tombstone) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Tombstone) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tombstone != nil {
		{
			size, err := m.Tombstone.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Header_Verify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Verify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Verify != nil {
		{
			size, err := m.Verify.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Header_HomoHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_HomoHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	{
		size := m.HomoHash.Size()
		i -= size
		if _, err := m.HomoHash.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func (m *Header_PayloadChecksum) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_PayloadChecksum) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PayloadChecksum != nil {
		i -= len(m.PayloadChecksum)
		copy(dAtA[i:], m.PayloadChecksum)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PayloadChecksum)))
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Header_Integrity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Integrity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Integrity != nil {
		{
			size, err := m.Integrity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Header_StorageGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_StorageGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageGroup != nil {
		{
			size, err := m.StorageGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Tombstone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tombstone) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tombstone) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Epoch != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SystemHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.CID.Size()
		i -= size
		if _, err := m.CID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.OwnerID.Size()
		i -= size
		if _, err := m.OwnerID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.ID.Size()
		i -= size
		if _, err := m.ID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.PayloadLength != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PayloadLength))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreationPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreationPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreationPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Epoch != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if m.UnixTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UnixTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IntegrityHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntegrityHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntegrityHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ChecksumSignature) > 0 {
		i -= len(m.ChecksumSignature)
		copy(dAtA[i:], m.ChecksumSignature)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ChecksumSignature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HeadersChecksum) > 0 {
		i -= len(m.HeadersChecksum)
		copy(dAtA[i:], m.HeadersChecksum)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HeadersChecksum)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Link) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Link) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Link) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size := m.ID.Size()
		i -= size
		if _, err := m.ID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Transform) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transform) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transform) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Object) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Object) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.SystemHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StorageGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Lifetime != nil {
		{
			size, err := m.Lifetime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.ValidationHash.Size()
		i -= size
		if _, err := m.ValidationHash.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ValidationDataSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ValidationDataSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StorageGroup_Lifetime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageGroup_Lifetime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageGroup_Lifetime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if m.Unit != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Unit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Offset != 0 {
		n += 1 + sovTypes(uint64(m.Offset))
	}
	if m.Length != 0 {
		n += 1 + sovTypes(uint64(m.Length))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Header_Link) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Link != nil {
		l = m.Link.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Header_Redirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Redirect != nil {
		l = m.Redirect.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Header_UserHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserHeader != nil {
		l = m.UserHeader.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Header_Transform) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transform != nil {
		l = m.Transform.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Header_Tombstone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tombstone != nil {
		l = m.Tombstone.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Header_Verify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Verify != nil {
		l = m.Verify.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Header_HomoHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.HomoHash.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Header_PayloadChecksum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PayloadChecksum != nil {
		l = len(m.PayloadChecksum)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Header_Integrity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Integrity != nil {
		l = m.Integrity.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Header_StorageGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageGroup != nil {
		l = m.StorageGroup.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Tombstone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovTypes(uint64(m.Epoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SystemHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovTypes(uint64(m.Version))
	}
	if m.PayloadLength != 0 {
		n += 1 + sovTypes(uint64(m.PayloadLength))
	}
	l = m.ID.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.OwnerID.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.CID.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.CreatedAt.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreationPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnixTime != 0 {
		n += 1 + sovTypes(uint64(m.UnixTime))
	}
	if m.Epoch != 0 {
		n += 1 + sovTypes(uint64(m.Epoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IntegrityHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HeadersChecksum)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ChecksumSignature)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Link) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = m.ID.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Transform) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Object) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SystemHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidationDataSize != 0 {
		n += 1 + sovTypes(uint64(m.ValidationDataSize))
	}
	l = m.ValidationHash.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.Lifetime != nil {
		l = m.Lifetime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageGroup_Lifetime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Unit != 0 {
		n += 1 + sovTypes(uint64(m.Unit))
	}
	if m.Value != 0 {
		n += 1 + sovTypes(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Link{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_Link{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redirect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &refs.Address{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_Redirect{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UserHeader{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_UserHeader{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Transform{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_Transform{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tombstone", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Tombstone{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_Tombstone{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verify", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &session.VerificationHeader{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_Verify{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomoHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var vv Hash
			v := &vv
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_HomoHash{*v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadChecksum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Value = &Header_PayloadChecksum{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Integrity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IntegrityHeader{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_Integrity{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StorageGroup{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_StorageGroup{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tombstone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tombstone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tombstone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadLength", wireType)
			}
			m.PayloadLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OwnerID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreationPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreationPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreationPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnixTime", wireType)
			}
			m.UnixTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnixTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntegrityHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntegrityHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntegrityHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadersChecksum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadersChecksum = append(m.HeadersChecksum[:0], dAtA[iNdEx:postIndex]...)
			if m.HeadersChecksum == nil {
				m.HeadersChecksum = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChecksumSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChecksumSignature = append(m.ChecksumSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.ChecksumSignature == nil {
				m.ChecksumSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Link) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Link_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transform) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transform: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transform: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Transform_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SystemHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, Header{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationDataSize", wireType)
			}
			m.ValidationDataSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidationDataSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ValidationHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lifetime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lifetime == nil {
				m.Lifetime = &StorageGroup_Lifetime{}
			}
			if err := m.Lifetime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageGroup_Lifetime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lifetime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lifetime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			m.Unit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unit |= StorageGroup_Lifetime_Unit(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
